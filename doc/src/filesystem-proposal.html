<html>
<!-- © Copyright Beman Dawes, 2002, 2006, 2007, 2009, 2010, 2011 -->
<!-- Distributed under the Boost Software License, Version 1.0. -->
<!-- See http://www.boost.org/LICENSE_1_0.txt -->


<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>

  Filesystem Proposal
  </title>
<style type="text/css">
/*

  © Copyright Beman Dawes, 2007

  Distributed under the Boost Software License, Version 1.0.
  See www.boost.org/LICENSE_1_0.txt
  
*/

body  {
        font-family: sans-serif;
        margin: 1em;
        max-width : 8.5in;
      }

table { margin: 0.5em; }

pre   { background-color:#D7EEFF }

ins   { background-color:#A0FFA0 }
del   { background-color:#FFA0A0 }

/*** end ***/
</style>
</head>

<body>
<p>7
  <table border="0">
    <tr>
      <td>Document number:&nbsp;&nbsp; </td>
      <td><span style="background-color: #FFFF99">D3399=12-0089</span></td>
    </tr>
    <tr>
      <td>Date:</td>
      <td>
      <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%Y-%m-%d" startspan -->2012-09-10<!--webbot bot="Timestamp" endspan i-checksum="12551" --></td>
    </tr>
    <tr>
      <td>Project:</td>
      <td>Programming Language C++</td>
    </tr>
    <tr>
      <td valign="top">Reply-to:</td>
      <td>Beman Dawes &lt;bdawes at acm dot org&gt;</td>
    </tr>
  </table>


<p><span style="font-style: italic; background-color: #FFFF99">Material 
high-lighted in yellow is specific to this draft and will be revised before it 
appears in a mailing.</span></p>


<h1><span style="background-color: #FFFF99">Draft,
<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B %Y" startspan -->10 September 2012<!--webbot bot="Timestamp" endspan i-checksum="39616" --></span><br>
Filesystem Library Proposal (Revision 3)</h1>


      <a href="#Introduction">Introduction</a><br>
      <a href="#Library-background">Library background</a><br>
      <a href="#Differences-Boost">Differences from Boost Filesystem</a><br>
      <a href="#Revision-history">Revision history</a><br>
      <a href="#TODO">TODO</a><br>
      <a href="#TOC">Proposed Wording Table of Contents</a><br>
      <a href="#Proposed-Wording">Proposed Wording</a><br>
      <a href="#Acknowledgements">Acknowledgements</a><br>
      <a href="#References">References</a>


<h2><a name="Introduction">Introduction</a></h2>


<p>This paper proposes a filesystem library component suitable for a <i>C++ 
Standard Library Technical Specification</i> or for the <i>C++ Standard Library</i>. 
The proposed library is based on the 
<a href="http://www.boost.org/libs/filesystem">Boost Filesystem Library</a>, 
version 3. Proposed wording is provided. A
<a href="#TODO">TODO</a> list identifies remaining work to be done.</p>


<p>The proposal is a pure addition; no existing standard library headers are modified. No 
special compiler or runtime support is required, although C++11 features are used where appropriate. The 
entire library is in a namespace within namespace <code>std</code>.</p>


<h2><a name="Library-background">Library background</a></h2>


<p>The Boost version of the library has been in widespread use for ten years. 
The Dinkumware version of the library, based on <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1975.html">
N1975</a> (equivalent to version 2 of the Boost library), ships with Microsoft 
Visual C++ 2012.</p>


<p>The motivation and scope for a filesystem library were described in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1975.html">
N1975</a>, and are not repeated here.</p>


<h2><a name="Differences-Boost">Differences from Boost Filesystem</a></h2>


<p>In the Boost library, class <code>path</code> has facilities to handle narrow 
(i.e. <code>char</code>) character strings with encodings other than the 
operating system's native encoding. These facilities have been removed from the 
Filesystem library proposal. Instead, proposal
<span style="background-color: #FFFF99">
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3398.html">N3398, String Interoperability Library</a></span>, 
provides general facilities that also handle the class <code>path</code> use 
cases.</p>


<p>Otherwise, the proposal is virtually identical to the Boost library. Indeed, 
the proposed wording is generated from the same source as the Boost library's 
reference documentation.</p>


<h2><a name="Revision-history">Revision history</a></h2>


<p><span style="background-color: #FFFF99">
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3399.html">D3399=12-0089</a></span>, Filesystem 
Library Proposal (Revision 3). Changes include:</p>


<ul>
  <li>Add path::operator+= and concat functions to tack on things like suffixes 
  or numbers. Suggested by Ed Smith-Rowland and others.</li>
    <li>Add section tags and section numbers, per LWG 
    discussion in Kona.</li>
  <li>Minimize use of trademarked names. Enclose uses in green highlighted boxes 
  to facilitate discussion. Apply footnote required by ISO/IEC directives.</li>
  <li>Introduce a definition for &quot;operating system dependent&quot;, and then use it 
  to replace &quot;implementation defined behavior&quot; wherever the operating 
  system's rules determine behavior.</li>
  <li>Replace uses of&nbsp; const string return types with non-const string 
  return types, per LWG discussion in Kona.</li>
  <li>Remove permission for implementations to return const string&amp; in certain 
  cases, per LWG discussion in Kona.</li>
  <li>Remove path inserter and extractor dependency on Boost quoted manip (Issue 
  7).</li>
  <li>Replace use of <code>time_t</code> with <code>file_time_type</code>, a 
  typedef for <code>std::chrono::system_clock::time_point</code>, per LWG 
  discussion in Kona.</li>
  <li>More consistent semantics and descriptions for return values from 
  operational functions with <code>error_code&amp;</code> arguments that encounter 
  an error. </li>
  <li><code>recursive_directory_iterator</code> specifications are now given in 
  terms of behavior only. Private &quot;for exposition only&quot; members have been 
  removed.</li>
  <li>
  <code>recursive_directory_iterator</code> functions <code>
  no_push_pending()</code> and <code>no_push()</code> have been renamed <code>
  recursion_pending()</code> and <code>disable_recursion_pending()</code>. 
  Option constant name <code>recurse</code> has been renamed <code>
  follow_directory_symlinks</code>.&nbsp; These are responses to a request from 
  Ed Smith-Rowland to improve clarity by reducing negative logic.</li>
  <li>
  A <code>recursive_directory_iterator</code> option <code>
  skip_permission_denied</code> has been added to skip directories with 
  permission denied, responding to several user requests.</li>
  <li>
  <code>symlink_option</code> has been renamed <code>
  directory_options</code>, since it has become more general and now covers both
  <code>follow_directory_symlinks</code> and <code>skip_permission_denied</code> 
  options.&nbsp;</li>
  <li>Add missing semantics  for <code>copy_directory</code>.</li>
  <li>Change template parameters for <code>path::string</code> and
  <code>path::generic_string</code> to the same as <code>std::basic_string</code> 
  in response to comments from the FSG.</li>
  <li>Remove <code>initial_path()</code> operational function. The functionality 
  as currently specified is trivial for a user to duplicate using <code>
  current_path()</code>. The original spec for <code>initial_path()</code> 
  required support from the runtime library. That doesn't appear to be 
  practical, and without it the motivation for the function is too weak for 
  standardization.</li>
  <li>Remove required changes to <code>&lt;fstream&gt;</code> header. The LWG 
  does not wish to require modifications existing headers. Also, the Dinkumware/Microsoft version 
  of the library has come up with a clever way to make class <code>path</code> 
  work with the existing <code>&lt;fstream&gt;</code> classes constructors and open 
  functions.</li>
  <li>Remove <code>directory_entry</code> as a <code>Source</code> in [path.req]. 
  It was Boost specific and is inappropriate for the standard library.</li>
  <li>Change name of <code>recursive_directory_iterator::level()</code> to <code>
  depth()</code>.</li>
  <li>
  <p>Change <code>enum file_type</code> to <code>enum class file_type</code>, 
  simplify constant names, supply explicit values for constant names; per FSG 
  discussions.</li>
  <li>
  <p>Change name of <code>copy_directory</code> function to <code>
  create_directory</code> to more clearly reflect semantics; per FSG 
  discussions.</li>
  <li>
  <p>Apply major functionality upgrade to <code>copy()</code>; per FSG 
  discussions.</li>
  <li>Add C++11 features to both the proposal and the Boost implementation and 
  test suite:<ul>
  <li>R-value reference move semantics.</li>
  <li><code>noexcept</code>.</li>
  <li><code>constexpr</code>.</li>
  <li>Scoped enums.</li>
  <li>Range-based for statement support.</li>
  <li>New character types.</li>
  <li>Replace explicit codecvt manipulation with a reference to <code>&lt;cuchar&gt;</code> 
  conversion facilities.</li>
</ul>


  </li>
</ul>


<p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3365.html">N3365=12-0055</a>, Filesystem Library Proposal (Revision 
2). Changes 
include:</p>


<ul>
  <li>Namespaces changed to <code>std::tbd::filesystem</code> per discussion in Kona.</li>
  <li>Removed references to Boost within the proposed wording.</li>
  <li>Minor fixes to the proposed wording.</li>
  <li>Added Issue 7: How should class path inserter and extractor be specified?</li>
  <li>Marked up all issues to reflect Kona LWG discussions.</li>
</ul>


<p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3335.html">
N3335=12-0025</a>, Filesystem Library for C++11/TR2 (Revision 1). Changes 
include:</p>


  <ul>
    <li>Regenerated the proposed wording from the Boost Filesystem library 
    reference documentation, using an automated process. This process reduces 
    the likelihood of inadvertent discrepancies between descriptions.</li>
    <li>An Issues list was added, seeded with issues 
    raised by the LWG review of N3239 at the Bloomington meeting, and private 
    communications from LWG members.</li>
    <li>Namespace changed to <code>files</code> as an experiment. Made this 
    issue number 1 so the LWG can pass judgment.</li>
    <li>New functions were added, suggested by David Svoboda, to generate 
    canonical paths and manage permissions.</li>
    <li>More C++11 functionality was applied. This process is still incomplete, 
    however.</li>
    <li>Added proposed changes to header &lt;fstream&gt;. The previous paper had 
    inadvertently supplied the wrong wording.</li>
    <li>Continued the general cleanup of wording.</li>
</ul>


<p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3239.html">
N3239 = 11-0009</a>, Filesystem Library Update for TR2 (Preliminary), reflected 
changes made to the Boost library version 3 since the previously accepted 
committee paper:</p>


  <ul>
    <li>A single class <code>path</code> handles all aspects of 
    internationalization, replacing the previous template and its <code>path</code> 
    and <code>wpath</code> instantiations. Character types <code>char</code>,
    <code>wchar_t</code>, <code>char16_t</code>, and <code>char32_t</code> are 
    supported. This is a major simplification of the path abstraction, 
    particularly for functions that take path arguments. This change was based 
    on a suggestion by Peter Dimov.</li>
    <li>Several operational functions have been added, including much better 
    symlink support, the ability to resize a file, and the ability to generate a 
    unique path.</li>
    <li>Support for error reporting via <code>error_code</code> is now uniform 
    throughout the operations functions.</li>
    <li>Several functions have been renamed, based on feedback from users.</li>
  </ul>


<p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1975.html">
N1975 = 06-0045</a>, Filesystem Library Proposal for TR2 (Revision 3), was 
adopted by the committee in April, 2006, at the Berlin meeting. Shortly 
afterward the Library Working Group set aside work on TR2 to concentrate on 
C++0x.</p>


  <h2><a name="TODO">TODO</a></h2>
  <ul>
    <li>Test, then add wording for, path automatic private conversion to const 
    string_type&amp; with &lt;fstream&gt; friendship. Allow implementers latitude to 
    instead add additional overloads to &lt;fstream&gt;.</li>
    <li><span style="background-color: #FFFF99">Update Acknowledgements.</span></li>
    <li>At Portland meeting, review trademarked names with Filesystem Study 
    Group and project editor.</li>
    <li>Ion Todirel suggests &quot;Would be nice if path::append was variadic, to 
    improve usability&quot;.</li>
    <li>Ion Todirel: Would be nice to have a make_relative. Need to review 
    similar suggestions.</li>
    <li>Dinkumware/Microsoft report slightly different results for Decomposition 
    table. Rerun table. Check discrepancies.</li>
    <li>Review Nick Stoughton's email for suggestions, action items.</li>
  </ul>
  
<h2>Proposed Wording <a name="TOC">Table of Contents</a></h2>

<p>   <a href="#Filesystem Library">1 Filesystem Library </a><br>
<a href="#Definitions">1.1 Definitions </a><br>
&nbsp;&nbsp;&nbsp;<a href="#Absolute-path">1.1.1 absolute path </a><br>
&nbsp;&nbsp;&nbsp;<a href="#canonical-path">1.1.2 canonical path </a><br>
&nbsp;&nbsp;&nbsp;<a href="#directory">1.1.3 directory </a><br>
&nbsp;&nbsp;&nbsp;<a href="#file">1.1.4 file </a><br>
&nbsp;&nbsp;&nbsp;<a href="#file-system">1.1.5 file system </a><br>
&nbsp;&nbsp;&nbsp;<a href="#file-system-race">1.1.6 file system race </a><br>
&nbsp;&nbsp;&nbsp;<a href="#filename">1.1.7 filename </a><br>
&nbsp;&nbsp;&nbsp;<a href="#hard-link">1.1.8 hard link </a><br>
&nbsp;&nbsp;&nbsp;<a href="#link">1.1.9 link </a><br>
&nbsp;&nbsp;&nbsp;<a href="#fs.def.native">1.1.10 native pathname format </a><br>
&nbsp;&nbsp;&nbsp;<a href="#NTCTS">1.1.11 NTCTS </a><br>
&nbsp;&nbsp;&nbsp;<a href="#operating system dependent">1.1.12 operating system dependent 
behavior </a><br>
&nbsp;&nbsp;&nbsp;<a href="#fs.def.parent">1.1.13 parent directory </a><br>
&nbsp;&nbsp;&nbsp;<a href="#path">1.1.14 path </a><br>
&nbsp;&nbsp;&nbsp;<a href="#fs.def.pathname">1.1.15 pathname </a><br>
&nbsp;&nbsp;&nbsp;<a href="#fs.def.pathres">1.1.16 pathname resolution </a><br>
&nbsp;&nbsp;&nbsp;<a href="#Relative-path">1.1.17 relative path </a><br>
&nbsp;&nbsp;&nbsp;<a href="#symbolic-link">1.1.18 symbolic link </a><br>
<a href="#Conformance">1.2 Conformance </a><br>
&nbsp;&nbsp;&nbsp;<a href="#fs.conform.9945">1.2.1 ISO/IEC 9945 conformance </a><br>
&nbsp;&nbsp;&nbsp;<a href="#fs.conform.os">1.2.2 Operating system dependent behavior 
conformance </a><br>
<a href="#fs.req">1.3 Requirements </a><br>
<a href="#Header-filesystem-synopsis">1.4 Header <code>&lt;filesystem&gt;</code> 
synopsis </a><br>
<a href="#Error-reporting">1.5 Error reporting </a><br>
<a href="#class-path">1.6 Class <code>path</code> </a><br>
&nbsp;&nbsp;&nbsp;<a href="#path.generic">1.6.1 Generic pathname format grammar </a><br>
&nbsp;&nbsp;&nbsp;<a href="#path-Conversions">1.6.2 <code>path</code> conversions </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#path-Conversions-to-native-format">1.6.2.1 <code>path</code> 
argument format conversions </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#path.arg.convert">1.6.2.2 <code>path</code> type and encoding 
conversions </a><br>
&nbsp;&nbsp;&nbsp;<a href="#path-Requirements">1.6.3 <code>path</code> Requirements </a><br>
&nbsp;&nbsp;&nbsp;<a href="#path-constructors">1.6.4 <code>path</code> constructors </a><br>
&nbsp;&nbsp;&nbsp;<a href="#path-assignments">1.6.5 <code>path</code> assignments </a><br>
&nbsp;&nbsp;&nbsp;<a href="#path-appends">1.6.6 <code><font size="4">path</font></code> appends
</a><br>
&nbsp;&nbsp;&nbsp;<a href="#path-concatenation">1.6.7 <code>path</code> concatenation </a><br>
&nbsp;&nbsp;&nbsp;<a href="#path-modifiers">1.6.8 <code>path</code> modifiers </a><br>
&nbsp;&nbsp;&nbsp;<a href="#path-native-format-observers">1.6.9 <code>path</code> native format 
observers </a><br>
&nbsp;&nbsp;&nbsp;<a href="#path-generic-format-observers">1.6.10 <code>path</code> generic 
format observers </a><br>
&nbsp;&nbsp;&nbsp;<a href="#path-compare">1.6.11 <code>path</code> compare </a><br>
&nbsp;&nbsp;&nbsp;<a href="#path-decomposition">1.6.12 <code>path</code> decomposition </a><br>
&nbsp;&nbsp;&nbsp;<a href="#path-query">1.6.13 <code>path</code> query </a><br>
&nbsp;&nbsp;&nbsp;<a href="#path-iterators">1.6.14 <code>path</code> iterators </a><br>
&nbsp;&nbsp;&nbsp;<a href="#path-non-member-functions">1.6.15 <code>path</code> non-member 
functions </a><br>
&nbsp;&nbsp;&nbsp;<a href="#path-inserter-extractor">1.6.16 <code>path</code> inserter and 
extractor </a><br>
<a href="#Class-filesystem_error">1.7 Class <code>filesystem_error</code> </a>
<br>
&nbsp;&nbsp;&nbsp;<a href="#filesystem_error-members">1.7.1 <code>filesystem_error</code> 
members </a><br>
<a href="#Enum-file_type">1.8 Enum class <code>file_type</code> </a><br>
<a href="#Enum-perms">1.9 Enum perms </a><br>
<a href="#file_status">1.10 Class file_status </a><br>
&nbsp;&nbsp;&nbsp;<a href="#file_status-constructors">1.10.1 <code>file_status</code> 
constructors </a><br>
&nbsp;&nbsp;&nbsp;<a href="#file_status-observers">1.10.2 <code>file_status</code> observers
</a><br>
&nbsp;&nbsp;&nbsp;<a href="#file_status-modifiers">1.10.3 <code>file_status</code> modifiers
</a><br>
<a href="#Class-directory_entry">1.11 Class <code>directory_entry</code> </a>
<br>
&nbsp;&nbsp;&nbsp;<a href="#directory_entry-constructors">1.11.1 <code>directory_entry </code>
constructors </a><br>
&nbsp;&nbsp;&nbsp;<a href="#directory_entry-modifiers">1.11.2 <code>directory_entry </code>
modifiers </a><br>
&nbsp;&nbsp;&nbsp;<a href="#directory_entry-observers">1.11.3 <code>directory_entry</code> 
observers </a><br>
<a href="#Class-directory_iterator">1.12 Class <code>directory_iterator</code>
</a><br>
&nbsp;&nbsp;&nbsp;<a href="#directory_iterator-members">1.12.1 <code>directory_iterator</code> 
members </a><br>
&nbsp;&nbsp;&nbsp;<a href="#directory_iterator-non-member-functions">1.12.2 <code>
directory_iterator</code> non-member functions </a><br>
<a href="#Class-recursive_directory_iterator">1.13 Class <code>
recursive_directory_iterator</code> </a><br>
&nbsp;&nbsp;&nbsp;<a href="#directory_iterator-members">1.13.1 <code>
recursive_directory_iterator</code> members </a><br>
&nbsp;&nbsp;&nbsp;<a href="#rec.dir.itr.nonmembers">1.13.2 <code>recursive_directory_iterator</code> 
non-member functions </a><br>
<a href="#Operational-functions">1.14 Operational functions </a><br>
<br>
</p>
      
<h2><a name="Proposed-Wording">Proposed Wording</a></h2>


<p>Gray-shaded italic text is commentary on the proposal. It is not to be added to 
the working paper.</p>

<p>Green shaded text in rectangular boxes calls attention to examples and notes 
intended to illuminate differences in behavior between operating systems. 
Trademarked names are used, as permitted by <a href="#ISO-Drafting">ISO/IEC Directives</a>, Part2, section 
6.6.3 <i>Use of trade names and trademarks</i>. It is the belief of the proposal author 
that these examples and notes add considerable clarity, and should be retained.</p>

<p><span style="font-style: italic; background-color: #E0E0E0">Start of proposed 
wording:</span></p>
<h1>1  <a name="Filesystem Library">Filesystem Library</a> [filesystem]</h1>

<p>This clause describes components that perform operations on file systems and 
their components, such as paths, regular files, and directories.</p>

<p>ISO/IEC 9945 contains provisions which, through referenced in this 
text, constitute provisions of this clause. At the time of 
publication, the editions indicated were valid. All standards are subject to 
revision, and parties to agreements based on this clause are 
encouraged to investigate the possibility of applying the most recent editions 
of the standard indicated below. Members of IEC and ISO maintain registers of 
currently valid International Standards.</p>
<ul>
  <li>ISO/IEC 9945:2003, <i>Portable Operating System Interface (POSIX</i>®<i>), 
  part 1 (Base Definitions) and part 2 (System Interfaces)</i>, both as 
  corrected by their respective 2004 Correction 1 documents.</li>
</ul>

<p>This clause  mentions commercially 
available operating systems for purposes of exposition.<sup> <a href="#footnote">
[footnote]</a></sup><p><i><span style="background-color: #E0E0E0">This footnote 
is required by ISO/IEC Directives, Part2, section 6.6.3 Use of trade names and 
trademarks:</span></i><p><sup>[<a name="footnote">footnote</a>]</sup> POSIX® is 
a registered trademark of The IEEE. MAC OS® is a registered trademark of Apple 
Inc. Windows® is a registered trademark of Microsoft Corporation. This information is given for the convenience of 
users of this document and does not constitute an endorsement by ISO or IEC of 
these products.<p><span style="background-color: #E0E0E0"><i>End of footnote.</i></span><p></p>

<h2>1.1  <a name="Definitions">Definitions</a> [fs.definitions]</h2>
<p>The following definitions  shall apply throughout this clause:</p>

<h3>1.1.1  <a name="Absolute-path">absolute path</a> [fs.def.absolute-path]</h3>
<p>A path that 
unambiguously 
identifies the location of a file without reference to an additional starting 
location. The elements of a path that determine if it is absolute are 
operating system dependent.</p>

<h3>1.1.2  <a name="canonical-path">canonical path</a> [fs.def.cannonical-path]</h3>
<p>An absolute path that has 
no elements that are symbolic links, and no dot or dot-dot elements ([<a href="#path.generic">path.generic</a>]).</p>
<h3>1.1.3  <a name="directory">directory</a> [fs.def.directory]</h3>
<p>A file within a file system that acts as a container of directory entries 
that contain information about 
other files, possibly including other directory files.</p>
<h3>1.1.4  <a name="file">file</a> [fs.def.file]</h3>
<p>An object within a file system that holds user or system data. Files can be written to, or read from, or both. A file 
has certain attributes, including type. File types include regular files 
and directories. Other types of files, such as symbolic links, may be supported by the 
implementation.</p>
<h3>1.1.5  <a name="file-system">file system</a> [fs.def.filesystem]</h3>
<p>A collection of files and certain of their attributes.</p>
<h3>1.1.6  <a name="file-system-race">file system race</a> [fs.def.race]</h3>
<p>The condition that occurs 
when multiple threads, processes, or computers interleave access and 
modification of 
the same object within a file system.</p>

<h3>1.1.7  <a name="filename">filename</a> [fs.def.filename]</h3>
  <p>The name of a file. Filenames dot&nbsp; 
and dot-dot&nbsp; have special meaning. The following characteristics of 
  filenames are operating system dependent:</p>
<ul>
  <li>
  <p>The permitted characters. [<i>Example</i>: Some operating systems prohibit the ASCII control characters (0x00-0x1F) 
    in filenames. <i>--end example</i>].</p>
  </li>
  <li>
  <p>Filenames that are not permitted.</p>
  </li>
  <li>
  <p>Filenames that have special meaning.</p>
  </li>
  <li>
  <p>Case awareness and sensitivity during path resolution.</p>
  </li>
  <li>
  <p>Special rules that may apply to file types other than regular 
  files, such as directories.</p>
  </li>
</ul>
<h3>1.1.8  <a name="hard-link">hard link</a> [fs.def.hardlink]</h3>
<p>A link ([fs.def.link]) to an existing file. Some 
file systems support multiple hard links to a file. If the last hard link to a 
file is removed, the file itself is removed.</p>
<blockquote>
<p>[<i>Note:</i> A hard link can be thought of as a shared-ownership smart 
pointer to a file.<i> -- end note</i>]<i> </i></p>
</blockquote>
<h3>1.1.9  <a name="link">link</a> [fs.def.link]</h3>
<p>A directory entry object that associates a 
filename with a file. A link is either a hard link ([fs.def.hardlink]) or a 
symbolic link ([fs.def.symlink]).</p>

<h3>1.1.10  native pathname format [<a name="fs.def.native">fs.def.native</a>]</h3>
<p>The operating system dependent pathname format accepted by the host operating system.</p>
<h3>1.1.11  <a name="NTCTS">NTCTS</a> [<a name="fs.def.ntcts">fs.def.ntcts</a>]</h3>
<p>Acronym for &quot;null-terminated character-type sequence&quot;. Describes a sequence 
of values of a given encoded character type terminated by that type's null character. If 
the encoded character type is <code>charT</code>, the null character can be constructed 
by <code>charT()</code>. <span style="background-color: #E0E0E0"><i>This is an 
expansion of the definition in chapter 17; that definition is very hard to 
parse. A request for clarification has been sent to the project editor.</i></span></p>
<h3>1.1.12  <a name="operating system dependent">operating system dependent</a> behavior 
[fs.def.osdep]</h3>
<p>Behavior  that is dependent upon the behavior 
and characteristics of an operating system. See [fs.conform.os].</p>
<h3>1.1.13  parent directory [<a name="fs.def.parent">fs.def.parent</a>]</h3>
<p>When discussing a given directory, the directory that both contains a 
directory entry for the given directory and is represented by the pathname 
dot-dot in the given directory.</p>
<p>When discussing other types of files, a directory containing a directory 
entry for the file under discussion.</p>
<p>This concept does not apply to dot and dot-dot.</p>
<h3>1.1.14  <a name="path">path</a> [fs.def.path]</h3>
<p>A sequence of elements that identify 
the location of a file within a filesystem. The elements are the <i>root-name<sub>opt</sub></i>, <i>
root-directory<sub>opt</sub></i>, and an optional sequence of filenames.</p>

<h3>1.1.15  pathname [<a name="fs.def.pathname">fs.def.pathname</a>]</h3>
<p>A character string that represents 
the name of a 
path. Pathnames are formatted according to the generic pathname format grammar 
([<a href="#path.generic">path.generic</a>]) or an 
operating system dependent 
native pathname format.</p>

<h3>1.1.16  pathname resolution [<a name="fs.def.pathres">fs.def.pathres</a>]</h3>

<p>Pathname resolution is the operating system dependent mechanism for resolving 
a pathname to a particular file in a file hierarchy. There may be multiple 
pathnames that resolve to the same file.&nbsp; [<i>Example:</i> The ISO/IEC 9945 
POSIX standard specifies the mechanism in section 4.11, Pathname resolution. <i>
--end example]</i></p>

<h3>1.1.17  <a name="Relative-path">relative path</a> [fs.def.relative-path]</h3>
<p>A path that 
is not absolute, and so only 
unambiguously 
identifies the location of a file when resolved relative to 
an implied starting location. The elements of a path that determine if it is 
relative are operating system dependent.&nbsp; [<i>Note:</i> 
Paths <code>&quot;.&quot;</code> and <code>&quot;..&quot;</code> are relative paths. <i>--end note</i>]</p>
<h3>1.1.18  <a name="symbolic-link">symbolic link</a> [fs.def.symlink]</h3>
<p>A link ([fs.def.link]) with the 
property that when the file is encountered during pathname resolution, a string 
stored by the file is used to modify the pathname resolution.</p>
<blockquote>
<p>[<i>Note:</i> Symbolic links are often called symlinks. A symbolic link can be thought of as a raw pointer to a file. 
If the file pointed to does not exist, the symbolic link is said to be a 
&quot;dangling&quot; symbolic link.<i> -- end note</i>]<i> </i></p>
</blockquote>

<h2>1.2  <a name="Conformance">Conformance</a> [fs.conformance]</h2>

<h3>1.2.1  ISO/IEC 9945 conformance [<a name="fs.conform.9945">fs.conform.9945</a>]</h3>
<p>Some behavior  is specified by reference to ISO/IEC 9945. How such behavior is actually implemented is unspecified.</p>
<blockquote>
<p>[<i>Note:</i> This constitutes an &quot;as if&quot; rule allowing implementations 
to call native 
operating system or other API's. <i>--end note</i>]</p>
</blockquote>
<p>Implementations are encouraged to provide such behavior 
 
as it is defined by ISO/IEC 9945. Implementations shall document any 
behavior that differs from the behavior defined by ISO/IEC 9945. Implementations that do not support exact 
ISO/IEC 9945 behavior are 
encouraged to provide behavior as close to ISO/IEC 9945 behavior as is reasonable given the 
limitations of actual operating systems and file systems. If an implementation cannot provide any 
reasonable behavior, the implementation shall report an error in an 
implementation-defined manner.</p>
<blockquote>
<p>[<i>Note:</i> Such errors might be reported by an #error directive, a <code>
static_assert</code>, a <code>filesystem_error</code> exception, a special 
return value, or some other manner. <i>--end note</i>]</p>
</blockquote>
<p>Implementations are not required to provide behavior that is not supported by 
a particular file system.</p>
<blockquote>
<p>[<i>Example:</i> The <a href="http://en.wikipedia.org/wiki/FAT_filesystem">
FAT file system</a> used by some memory cards, camera memory, and floppy discs 
does not support hard links, symlinks, and many other features of more capable 
file systems, so implementations are not required to support those features 
on the FAT file system. <i>-- end example</i>]</p>
</blockquote>
<p>The behavior of functions described in this 
clause 
may differ from their specification in 
the presence of <a href="#file-system-race">file system races</a> ([fs.def.race]). No diagnostic is required.</p>
<p>If the possibility of a file system race would make it unreliable for a program to 
test for a precondition before calling a function described herein, <i>
Requires</i> is not specified for the function.</p>
<blockquote>
<p>[<i>Note:</i> As a design practice, preconditions are not specified when it 
is unreasonable for a program to detect them prior to calling the function. <i>
-- end note</i>]</p>
</blockquote>
<h3>1.2.2  Operating system dependent behavior conformance [<a name="fs.conform.os">fs.conform.os</a>]</h3>
<p>Some behavior is specified as being 
operating system dependent ([fs.def.osdep]). The operating system an 
implementation is dependent upon is implementation defined.</p>
<p>It is permissible for an implementation to be dependent upon an operating 
system emulator rather than the actual underlying operating system.</p>
<h2>1.3  Requirements [<a name="fs.req">fs.req</a>]</h2>
<p>Throughout this clause, <code>char</code>, <code>wchar_t</code>,
<code>char16_t</code>, and <code>char32_t</code> are collectively called <i>
encoded character types</i>.</p>

<p>Template parameters named <code>charT</code> shall be one of the 
encoded character types.</p>

<p>Template parameters named <code>InputIterator</code> shall meet the 
C++ standard library input iterator requirements ([input.iterators]) and shall 
have a value type that is one of the encoded character types.</p>

<blockquote>
<p>[<i>Note:</i> Use of an encoded character type implies an associated 
encoding. Since <code>signed char</code> and <code>unsigned char</code> have no 
implied encoding, they are not included as permitted types. <i>--end note</i>]</p>

<p><span style="background-color: #E0E0E0"><i>To permit UDT types 
would require providing a way to specify type and encoding conversion 
mechanisms. That might be worth considering in the future if some form of a 
String Interoperability proposal is accepted, but as it stands now would involve 
exposing numerous implementation details so is not proposed here.</i></span></p>

</blockquote>
<h2>1.4  <a name="Header-filesystem-synopsis">Header <code>&lt;filesystem&gt;</code> synopsis</a> 
[filesystem.synopsis]</h2>
<pre>namespace std { namespace tbd { namespace filesystem {

    class <a href="#class-path">path</a>;
    
    void swap(path&amp; lhs, path&amp; rhs) noexcept;
    size_t <a href="#hash_value">hash_value</a>(const path&amp; p) noexcept;

    bool operator==(const path&amp; lhs, const path&amp; rhs) noexcept;
    bool operator!=(const path&amp; lhs, const path&amp; rhs) noexcept;
    bool operator&lt; (const path&amp; lhs, const path&amp; rhs) noexcept;
    bool operator&lt;=(const path&amp; lhs, const path&amp; rhs) noexcept;
    bool operator&gt; (const path&amp; lhs, const path&amp; rhs) noexcept;
    bool operator&gt;=(const path&amp; lhs, const path&amp; rhs) noexcept;

    path operator/ (const path&amp; lhs, const path&amp; rhs);

    template &lt;class charT, class traits&gt;
    basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const path&amp; p);

    template &lt;class charT, class traits&gt;
    basic_istream&lt;charT, traits&gt;&amp;
    operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, path&amp; p);

    class <a href="#Class-filesystem_error">filesystem_error</a>;      
    class <a href="#Class-directory_entry">directory_entry</a>;

    class <a href="#Class-directory_iterator">directory_iterator</a>;

    // enable c++11 range-based for statements
    const directory_iterator&amp; <a href="#directory_iterator-non-member-functions">begin</a>(const directory_iterator&amp; iter) noexcept;
    directory_iterator <a href="#directory_iterator-non-member-functions">end</a>(const directory_iterator&amp;) noexcept;

    class <a href="#Class-recursive_directory_iterator">recursive_directory_iterator</a>;

    // enable c++11 range-based for statements
    const recursive_directory_iterator&amp; <a href="#recursive_directory_iterator-non-member-functions">begin</a>(const recursive_directory_iterator&amp; iter) noexcept;
    recursive_directory_iterator <a href="#recursive_directory_iterator-non-member-functions">end</a>(const recursive_directory_iterator&amp;) noexcept;

    enum class <a name="file_type" href="#Enum-file_type">file_type</a>;  // [<a href="#Enum-file_type">enum.file_type</a>]

    enum <a href="#Enum-perms">perms</a>
    {
      no_perms,
      owner_read, owner_write, owner_exe, owner_all,
      group_read, group_write, group_exe, group_all,
      others_read, others_write, others_exe, others_all, all_all,
      set_uid_on_exe, set_gid_on_exe, sticky_bit,
      perms_mask, perms_not_known,
      add_perms, remove_perms, symlink_perms
    };

    class <a href="#file_status">file_status</a>;

    struct <a name="space_info">space_info</a>  // returned by <a href="#space" style="text-decoration: none">space</a> function
    {
      uintmax_t capacity;
      uintmax_t free; 
      uintmax_t available; // free space available to a non-privileged process
    };

    enum class <a name="copy_option" href="#enum.copy_options">copy_options</a>;  // [<a href="#enum.copy_options">enum.copy_options</a>]

    enum class <a name="symlink_option">directory_options</a>
    {
      none,
      follow_directory_symlink,
      skip_permission_denied
    };

    typedef chrono::time_point&lt;<b><i>unspecified-trivial-clock</i></b>&gt;  file_time_type;

    // <a href="#Operational-functions">operational functions</a>

    path         <a href="#absolute">absolute</a>(const path&amp; p, const path&amp; base=current_path());

    path         <a href="#canonical">canonical</a>(const path&amp; p, const path&amp; base = current_path());
    path         <a href="#canonical">canonical</a>(const path&amp; p, error_code&amp; ec);
    path         <a href="#canonical">canonical</a>(const path&amp; p, const path&amp; base, error_code&amp; ec);

    void         <a href="#copy">copy</a>(const path&amp; from, const path&amp; to);
    void         <a href="#copy">copy</a>(const path&amp; from, const path&amp; to, error_code&amp; ec) noexcept;

    void         <a href="#copy_file">copy_file</a>(const path&amp; from, const path&amp; to);
    void         <a href="#copy_file">copy_file</a>(const path&amp; from, const path&amp; to, error_code&amp; ec) noexcept;
    void         <a href="#copy_file">copy_file</a>(const path&amp; from, const path&amp; to, <a href="#copy_option">copy_options</a> option);
    void         <a href="#copy_file">copy_file</a>(const path&amp; from, const path&amp; to, <a href="#copy_option">copy_options</a> option,
                           error_code&amp; ec) noexcept;

    void         <a href="#copy_symlink">copy_symlink</a>(const path&amp; existing_symlink, const path&amp; new_symlink);
    void         <a href="#copy_symlink">copy_symlink</a>(const path&amp; existing_symlink, const path&amp; new_symlink,
                              error_code&amp; ec) noexcept;

    bool         <a href="#create_directories">create_directories</a>(const path&amp; p);
    bool         <a href="#create_directories">create_directories</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#create_directory">create_directory</a>(const path&amp; p);
    bool         <a href="#create_directory">create_directory</a>(const path&amp; p, error_code&amp; ec) noexcept;

    void         <a href="#create_directory2">create_directory</a>(const path&amp; p, const path&amp; attributes);
    void         <a href="#create_directory2">create_directory</a>(const path&amp; p, const path&amp; attributes, error_code&amp; ec) noexcept;

    void         <a href="#create_directory_symlink">create_directory_symlink</a>(const path&amp; to, const path&amp; new_symlink);
    void         <a href="#create_directory_symlink">create_directory_symlink</a>(const path&amp; to, const path&amp; new_symlink,
                                          error_code&amp; ec) noexcept;

    void         <a href="#create_hard_link">create_hard_link</a>(const path&amp; to, const path&amp; new_hard_link);
    void         <a href="#create_hard_link">create_hard_link</a>(const path&amp; to, const path&amp; new_hard_link,
                                  error_code&amp; ec) noexcept;

    void         <a href="#create_symlink">create_symlink</a>(const path&amp; to, const path&amp; new_symlink);
    void         <a href="#create_symlink">create_symlink</a>(const path&amp; to, const path&amp; new_symlink,
                                error_code&amp; ec) noexcept;

    path         <a href="#current_path">current_path</a>();
    path         <a href="#current_path">current_path</a>(error_code&amp; ec);
    void         <a href="#current_path">current_path</a>(const path&amp; p);
    void         <a href="#current_path">current_path</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#exists">exists</a>(file_status s) noexcept;
    bool         <a href="#exists">exists</a>(const path&amp; p);
    bool         <a href="#exists">exists</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#equivalent">equivalent</a>(const path&amp; p1, const path&amp; p2);
    bool         <a href="#equivalent">equivalent</a>(const path&amp; p1, const path&amp; p2, error_code&amp; ec) noexcept;

    uintmax_t    <a href="#file_size">file_size</a>(const path&amp; p);
    uintmax_t    <a href="#file_size">file_size</a>(const path&amp; p, error_code&amp; ec) noexcept;

    uintmax_t    <a href="#hard_link_count">hard_link_count</a>(const path&amp; p);
    uintmax_t    <a href="#hard_link_count">hard_link_count</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#is_block_file">is_block_file</a>(file_status s) noexcept;
    bool         <a href="#is_block_file">is_block_file</a>(const path&amp; p,);
    bool         <a href="#is_block_file">is_block_file</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#is_character_file">is_character_file</a>(file_status s) noexcept;
    bool         <a href="#is_character_file">is_character_file</a>(const path&amp; p,);
    bool         <a href="#is_character_file">is_character_file</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#is_block_file">is_directory</a>(file_status s) noexcept;
    bool         <a href="#is_directory2">is_directory</a>(const path&amp; p);
    bool         <a href="#is_directory2">is_directory</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#is_empty">is_empty</a>(const path&amp; p);
    bool         <a href="#is_empty">is_empty</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#is_fifo">is_fifo</a>(file_status s) noexcept;
    bool         <a href="#is_fifo">is_fifo</a>(const path&amp; p,);
    bool         <a href="#is_fifo">is_fifo</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#is_other">is_other</a>(file_status s) noexcept;
    bool         <a href="#is_other2">is_other</a>(const path&amp; p,);
    bool         <a href="#is_other2">is_other</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#is_regular_file">is_regular_file</a>(file_status s) noexcept; 
    bool         i<a href="#is_regular_file2">s_regular_file</a>(const path&amp; p);
    bool         i<a href="#is_regular_file2">s_regular_file</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#is_socket">is_socket</a>(file_status s) noexcept;
    bool         <a href="#is_socket">is_socket</a>(const path&amp; p,);
    bool         <a href="#is_socket">is_socket</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#is_symlink">is_symlink</a>(file_status s) noexcept;
    bool         <a href="#is_symlink2">is_symlink</a>(const path&amp; p);
    bool         <a href="#is_symlink2">is_symlink</a>(const path&amp; p, error_code&amp; ec) noexcept;

    file_time_type  <a href="#last_write_time">last_write_time</a>(const path&amp; p);
    file_time_type  <a href="#last_write_time">last_write_time</a>(const path&amp; p, error_code&amp; ec) noexcept;
    void         <a href="#last_write_time2">last_write_time</a>(const path&amp; p, file_time_type new_time);
    void         <a href="#last_write_time2">last_write_time</a>(const path&amp; p, file_time_type new_time,
                                 error_code&amp; ec) noexcept;

    path         <a href="#read_symlink">read_symlink</a>(const path&amp; p);
    path         <a href="#read_symlink">read_symlink</a>(const path&amp; p, error_code&amp; ec);

    bool         <a href="#remove">remove</a>(const path&amp; p);
    bool         <a href="#remove">remove</a>(const path&amp; p, error_code&amp; ec) noexcept;

    uintmax_t    <a href="#remove_all">remove_all</a>(const path&amp; p);
    uintmax_t    <a href="#remove_all">remove_all</a>(const path&amp; p, error_code&amp; ec) noexcept;

    void         <a href="#rename">rename</a>(const path&amp; from, const path&amp; to);
    void         <a href="#rename">rename</a>(const path&amp; from, const path&amp; to, error_code&amp; ec) noexcept;

    void         <a href="#resize_file">resize_file</a>(const path&amp; p, uintmax_t size);
    void         <a href="#resize_file2">resize_file</a>(const path&amp; p, uintmax_t size, error_code&amp; ec) noexcept;

    <a href="#space_info">space_info</a>   <a href="#space">space</a>(const path&amp; p);
    <a href="#space_info">space_info</a>   <a href="#space">space</a>(const path&amp; p, error_code&amp; ec) noexcept;

    <a href="#file_status">file_status</a>  <a href="#status">status</a>(const path&amp; p);
    <a href="#file_status">file_status</a>  <a href="#status">status</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#status_known">status_known</a>(file_status s) noexcept;

    <a href="#file_status">file_status</a>  <a href="#symlink_status">symlink_status</a>(const path&amp; p);
    <a href="#file_status">file_status</a>  <a href="#symlink_status">symlink_status</a>(const path&amp; p, error_code&amp; ec) noexcept;

    path         <a href="#system_complete">system_complete</a>(const path&amp; p);
    path         <a href="#system_complete">system_complete</a>(const path&amp; p, error_code&amp; ec);

    path         <a href="#temp_directory_path">temp_directory_path</a>();
    path         <a href="#temp_directory_path">temp_directory_path</a>(error_code&amp; ec);

    path         <a href="#unique_path">unique_path</a>(const path&amp; model=&quot;%%%%-%%%%-%%%%-%%%%&quot;);
    path         <a href="#unique_path">unique_path</a>(const path&amp; model, error_code&amp; ec);

} } }  // namespaces std::tbd::filesystem</pre>

 <p><b><i><code>unspecified-trivial-clock</code></i></b> is an unspecified type 
provided by the implementation that satisfies the TrivialClock requirements ([time.clock.req]) 
 and that is capable of representing and measuring file time values.</p>
<h2>1.5  <a name="Error-reporting">Error reporting</a> [fs.err.report]</h2>
<p>Filesystem library functions often provide two overloads, one that 
throws an exception to report file system errors, and another that sets an <code>error_code</code>.</p>
<blockquote>
<p>[<i>Note:</i> This supports two common use cases:</p>
<ul>
  <li>Uses where file system 
errors are truly exceptional and indicate a serious failure. Throwing an 
  exception is the most appropriate response. This is the preferred default for 
  most everyday programming.<br>
&nbsp;</li>
  <li>Uses where file system system errors are routine and do not necessarily represent 
  failure. Returning an error code is the most appropriate response. This allows 
  application specific error handling, including simply ignoring the error.</li>
</ul>
  <p><i>--end note</i>]</p>
</blockquote>
<p>Functions <b>not</b> having an argument of type <code>error_code&amp;</code> report errors as follows, unless otherwise specified:</p>
  <ul>
  <li>When a call by the 
  implementation to an operating system or other underlying API results in an 
  error that prevents the function from meeting its specifications, an exception 
  of type
<code>filesystem_error</code> shall be thrown. For functions with a single path 
  argument, that argument shall be passed to the
<code>filesystem_error</code> constructor with a single path argument.&nbsp; For 
  functions with two path arguments, the first of these arguments shall be 
  passed to the
<code>filesystem_error</code> constructor as the <code>path1</code> argument, 
  and the second shall be passed as the <code>path2</code> argument.<br>
&nbsp;</li>
  <li>Failure to allocate storage is reported by throwing an exception as described in the C++ standard, 
  17.6.4.10 [res.on.exception.handling].<br>
&nbsp;</li>
  <li>Destructors throw nothing.</li>
  </ul>
  <p>Functions having an argument of type <code>error_code&amp;</code> report errors as follows, unless otherwise 
  specified:</p>
<ul>
  <li>If a call by the 
  implementation to an operating system or other underlying API results in an 
  error that prevents the function from meeting its specifications, the
<code>error_code&amp;</code> argument is set as 
  appropriate appropriate for the specific error. Otherwise, <code>clear()</code> 
  is called on the
<code>error_code&amp;</code> argument.</li>
</ul>
<h2>1.6  <a name="class-path">Class <code>path</code> [class.path]</a></h2>
<p>An object of class <code>path</code> represents a <a href="#class-path">path</a>, 
and contains a <a href="#fs.def.pathname">pathname</a> Such an object is concerned only with the lexical and syntactic aspects 
of a path. The path does not necessarily exist in external storage, and the 
pathname is not necessarily valid for the current operating 
system or for a particular file system.</p>
<blockquote>
<pre>namespace std { namespace tbd { namespace filesystem {

      class path
      {
      public:
        typedef <b><i><a href="#value_type">see below</a></i></b>                      value_type;
        typedef basic_string&lt;value_type&gt;       string_type;
        static constexpr value_type            preferred_separator = <b><i><a href="#value_type">see below</a></i></b>;

        // <a href="#path-constructors">constructors</a> and destructor
        path() = default;
        path(const path&) = default;
        path(path&amp;&amp;) noexcept = default;

        template &lt;class <a href="#Source">Source</a>&gt;
          path(Source const&amp; source);

        template &lt;class InputIterator&gt;
          path(InputIterator begin, InputIterator end);

       ~path() = default;

        // <a href="#path-assignments">assignments</a>
        path&amp; operator=(const path&amp;) = default;
        path&amp; operator=(path&amp;&amp;) noexcept = default;

        template &lt;class <a href="#Source">Source</a>&gt;
          path&amp; operator=(Source const&amp; source);

        template &lt;class InputIterator&gt;
          path&amp; assign(InputIterator begin, InputIterator end);

        // <a href="#path-appends">appends</a>
        path&amp; operator/=(const path&amp; p);

        template &lt;class <a href="#Source">Source</a>&gt;
          path&amp; operator/=(Source const&amp; source);

        template &lt;class InputIterator&gt;
          path&amp; append(InputIterator begin, InputIterator end);

        // <a href="#path-concatenation">concatenation</a>
        path&amp; operator+=(const path&amp; x);
        path&amp; operator+=(const string_type&amp; x);
        path&amp; operator+=(const value_type* x);
        path&amp; operator+=(value_type x);
        template &lt;class Source&gt;
          path&amp; operator+=(Source const&amp; x);
        template &lt;class charT&gt;
          path&amp; operator+=(charT x);
        template &lt;class InputIterator&gt;
          path&amp; concat(InputIterator begin, InputIterator end);
        template &lt;class InputIterator&gt;
          path&amp; concat(InputIterator begin, InputIterator end);
        
        // <a href="#path-modifiers">modifiers</a>
        void  <a href="#path-clear">clear</a>() noexcept;
        path&amp; <a href="#path-make_preferred">make_preferred</a>();
        path&amp; <a href="#path-remove_filename">remove_filename</a>();
        path&amp; <a href="#path-replace_extension">replace_extension</a>(const path&amp; new_extension = path());
        void  <a href="#path-swap">swap</a>(path&amp; rhs) noexcept;

        // <a href="#path-native-format-observers">native format observers</a>
        const string_type&amp;  <a href="#native">native</a>() const noexcept;  // native format, encoding
        const value_type*   <a href="#c_str">c_str</a>() const noexcept;   // native().c_str()

        template &lt;class charT, class traits= char_traits&lt;charT&gt;,
                  class Allocator = allocator&lt;charT&gt; &gt;
        basic_string&lt;charT, traits, Allocator&gt;
          <a href="#string-template">string</a>(const Allocator&amp; a = Allocator()) const;

        string    <a href="#string">string</a>() const;
        wstring   <a href="#wstring">wstring</a>() const;
        u16string <a href="#u16string">u16string</a>() const;
        u32string <a href="#u32string">u32string</a>() const;

        // <a href="#path-generic-format-observers">generic format observers</a>
        template &lt;class charT, class traits= char_traits&lt;charT&gt;,
                  class Allocator = allocator&lt;charT&gt; &gt;
        basic_string&lt;charT, traits, Allocator&gt;
          <a href="#generic_string-template">generic_string</a>(const Allocator&amp; a = Allocator()) const;

        string    <a href="#generic_string">generic_string</a>() const;
        wstring   <a href="#generic_wstring">generic_wstring</a>() const;
        u16string <a href="#generic_u16string">generic_u16string</a>() const;
        u32string <a href="#generic_u32string">generic_u32string</a>() const;

        // <a href="#path-compare">compare</a>
        int  <a href="#path-compare">compare</a>(const path&amp; p) const noexcept;
        int  <a href="#path-compare">compare</a>(const string&amp; s) const;
        int  <a href="#path-compare">compare</a>(const value_type* s) const;

        // <a href="#path-decomposition">decomposition</a>
        path <a href="#path-root_name">root_name</a>() const;
        path <a href="#path-root_directory">root_directory</a>() const;
        path <a href="#path-root_path">root_path</a>() const;
        path <a href="#path-relative_path">relative_path</a>() const;
        path <a href="#path-parent_path">parent_path</a>() const;
        path <a href="#path-filename">filename</a>() const;
        path <a href="#path-stem">stem</a>() const;
        path <a href="#path-extension">extension</a>() const;

        // <a href="#path-query">query</a>
        bool <a href="#path-query">empty</a>() const noexcept;
        bool <a href="#path-has_root_name">has_root_name</a>() const;
        bool <a href="#path-has_root_directory">has_root_directory</a>() const;
        bool <a href="#path-has_root_path">has_root_path</a>() const;
        bool <a href="#path-has_relative_path">has_relative_path</a>() const;
        bool <a href="#path-has_parent_path">has_parent_path</a>() const;
        bool <a href="#path-has_filename">has_filename</a>() const;
        bool <a href="#path-has_stem">has_stem</a>() const;
        bool <a href="#path-has_extension">has_extension</a>() const;
        bool <a href="#path-is_absolute">is_absolute</a>() const;
        bool <a href="#path-is_relative">is_relative</a>() const;

        // <a href="#path-iterators">iterators</a>
        class iterator;
        typedef iterator const_iterator;

        iterator begin() const;
        iterator end() const;

      private:
        string_type pathname;  // <b><i>exposition only</i></b>
      };

} } }  // namespaces std::tbd::filesystem</pre>

</blockquote>
<p><code><a name="value_type">value_type</a></code> is a <code>typedef</code> for the 
operating system dependent encoded character type used  to represent pathnames.</p>
<p>The value of <a name="preferred_separator"><code>preferred_separator</code></a> 
is the operating system dependent <i>preferred-separator</i> character ([path.generic]).</p>
<blockquote>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse"
   bordercolor="#111111" width="90%" bgcolor="#E8FFE8">
    <tr>
      <td width="100%">[<i>Example:</i> For ISO 9945/POSIX based operating 
      systems, <code>value_type</code> is <code>char</code> and <code>
      preferred_separator</code> is the slash character.&nbsp; For Windows based 
operating systems, <code>value_type</code> is <code>wchar_t</code> and <code>
      preferred_separator</code> is the backslash character.&nbsp; <i>--end example</i>]</td>
    </tr>
  </table>
</blockquote>
<h3>1.6.1  Generic pathname format grammar [<a name="path.generic">path.generic</a>]</h3>
<p><i>pathname:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root-name 
root-directory<sub>opt</sub> relative-path<sub>opt<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </sub>root-directory relative-path<sub>opt<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </sub>relative-path</i></p>
<p><i>root-name:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </i>An 
operating system dependent name that identifies the starting location for 
absolute paths. </p>
<blockquote>
  <blockquote>
<p>[<i>Note:</i> Many operating systems define a name 
beginning with two <i>directory-separator</i> characters as a <i>root-name</i> 
that identifies network or other resource locations. Some operating systems define a single letter followed by a colon as a drive 
specifier - a <i>root-name</i> identifying a specific device such as a disc drive. <i>--end note</i>]</p>
  </blockquote>
</blockquote>
<p><i>root-directory:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
directory-separator<br>
<br>
relative-path:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
filename<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; relative-path 
directory-separator<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; relative-path 
directory-separator filename<br>
<br>
filename:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dot<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dot-dot<br>
<br>
name:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </i>A 
sequence of characters other than <i>directory-separator</i> characters.</p>
<blockquote>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse"
   bordercolor="#111111" width="90%" bgcolor="#E8FFE8">
    <tr>
      <td width="100%">[<i>Note:</i> Operating systems often place restrictions 
      on the characters that may be used in a <i>filename</i>. For wide 
      portability, users may wish to limit <i>filename</i> characters to the ISO 
      9945/POSIX Portable Filename Character Set: <br>
      <br>
      <tt>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z<br>
      a b c d e f g h i j k l m n o p q r s t u v w x y z<br>
      0 1 2 3 4 5 6 7 8 9 . _ -<br>
      <br>
      </tt> <i>--end note</i>]</td>
    </tr>
  </table>
</blockquote>
<p><i>dot:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </i>The 
filename consisting solely of a single period (.) character.<br>
<br>
<i>dot-dot:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </i>The 
filename consisting solely of two period (..) characters.<br>
<br>
<i>directory-separator:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slash<code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>slash directory-separator<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
preferred-separator<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
preferred-separator directory-separator<br>
<br>
preferred-separator:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </i>An 
operating system dependent directory separator character. May be a synonym for
<i>slash</i>.<br>
<br>
<i>slash:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </i>The slash (/) 
character. </p>
<p>Multiple successive <i>directory-separator</i> characters are considered to 
be the same as one <i>directory-separator</i> character.</p>
<p>The filename <i>dot</i> is treated as a reference to the current directory. The filename <i>
dot-dot</i> is treated as a reference to the 
parent 
directory. Specific filenames may have special meanings for a particular 
operating system.</p>
<h3>1.6.2  <a name="path-Conversions"><code>path</code> conversions</a> [path.cvt]</h3>
<h4>1.6.2.1  <a name="path-Conversions-to-native-format"><code>path</code> argument 
format conversions</a> [path.fmt.cvt]</h4>
<p>Member functions arguments that take character sequences representing paths 
may use the generic pathname format grammar ([<a href="#path.generic">path.generic</a>]) or 
the <a href="#fs.def.native">native pathname format</a>. Iff such 
arguments are in the generic format and the generic format is not acceptable to 
the operating system as a native path, conversion to native format shall be 
performed during the processing of the argument. </p>
<blockquote>
<p>[<i>Note:</i> Some operating systems may have no unambiguous way to distinguish between native format and generic format arguments. 
This is by design as it simplifies use for operating systems that do not require 
disambiguation. An implementation for an operating system where disambiguation 
is required is permitted 
as an extension to distinguish between the formats. <i>
-- end note</i>]</p>
</blockquote>

<p>If the native format requires paths for regular files to be formatted 
differently from paths for directories, the path shall be treated as a directory 
path if last element is <i>directory-separator</i>, 
otherwise it shall be treated as a regular file path.</p>
<blockquote>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse"
   bordercolor="#111111" width="90%" bgcolor="#E8FFE8">
    <tr>
      <td width="100%">[<i>Note:</i> For ISO 9945/POSIX and Windows based operating 
      systems,<ul>
        <li>The generic format is acceptable as a native path so paragraph 1 
        does not apply and format 
        conversion is not performed.</li>
        <li>There is no need to distinguish between native format and generic 
        format arguments so paragraph 1 does not apply and&nbsp; no extension is required.</li>
        <li>Paths for regular files and paths for directories share the same 
      syntax so paragraph 1 does not apply and there is no special treatment for a path with a last element of
      <i>directory-separator</i>.</li>
      </ul>
      <p>&nbsp;<i>-- end note</i>]</td>
    </tr>
  </table>
</blockquote>
<h4>1.6.2.2  <code>path</code> type and encoding conversions [<a name="path.arg.convert">path.type.cvt</a>]</h4>
<p>For member function arguments that take character sequences representing 
paths and for member function returning strings, value type and encoding 
conversion is performed if the value type of the argument or return differs from <code>
path::value_type</code>. Encoding is determined based on the value type:</p>
<blockquote>
  <ul>
    <li>
<p><code>char</code>: Operating system dependent narrow character path 
encoding. [<i>Note:</i> The intent is to preserve the current behavior of C and C++ 
standard library functions that perform file operations using narrow character 
strings to identify paths. Changing this behavior would be surprising and break 
much existing code. <i>--end note</i>]</p>
    </li>
    <li>
<p><code>wchar_t</code>: Encoding of the implementation's native wide 
character set.</p>
    </li>
    <li>
<p><code>char16_t</code>: UTF-16</p>
    </li>
    <li>
<p><code>char32_t</code>: UTF-32</p>
    </li>
  </ul>
<blockquote>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse"
   bordercolor="#111111" width="90%" bgcolor="#E8FFE8">
    <tr>
      <td width="100%">[<i>Note:</i> Native narrow character path encoding 
      varies considerably:<ul>
        <li>
        <p>MAC OS X operating system: Always UTF-8.</li>
        <li>Some ISO 9945/POSIX based operating systems: determined by <code>locale(&quot;&quot;)</code>;</li>
        <li>Windows based operating systems: Codepage of <code>CP_ACP</code> 
    if <code>AreFileApisANSI()</code>is true, otherwise codepage <code>CP_OEMCP</code>.</li>
      </ul>
      <p>&nbsp;<i>-- end note</i>]</td>
    </tr>
  </table>
</blockquote>

</blockquote>
<h3>1.6.3  <a name="path-Requirements"><code>path</code> Requirements</a> [path.req]</h3>
<p>In addition to the [fs.req] requirements, template parameters named <code><a name="Source">Source</a></code> 
shall be one of:</p>
<ul>
  <li>Type <code>basic_string&lt;charT, traits, Allocator&gt;</code>. The type <code>
  charT</code> shall be an encoded character type ([fs.req]).</li>
  <li>A type meeting the input iterator requirements that iterates over a NTCTS. 
  The value type shall be an encoded character type.</li>
  <li>A character array that after array-to-pointer conversion results in a 
  pointer to a NTCTS. The value type shall be an encoded character type.</li>
</ul>

<blockquote>
  <p>[<i>Note:</i> See <a href="#path-Conversions">path conversions</a> ([path.cvt]) 
  for how these value types and their encodings convert to <code>
  path::value_type</code> and its encoding. <i>-- end note</i>]</p>
</blockquote>

<h3>1.6.4   <a name="path-constructors"> <code>
path</code> constructors</a> [path.construct]</h3>
<pre>template &lt;class <a href="#Source">Source</a>&gt;
  path(Source const&amp; source);</pre>
<pre>template &lt;class InputIterator&gt;
  path(InputIterator begin, InputIterator end);</pre>
<blockquote>
  <p><i>Effects:</i> Stores the contents [<code>begin</code>,<code>end</code>) 
  or <code>source</code> in <code>pathname</code>, converting format and 
  encoding if required ([<a href="#path.arg.convert">path.arg.convert</a>]).</p>
</blockquote>
<h3>1.6.5   <a name="path-assignments"> <code>
path</code> assignments</a> [path.assign]</h3>
<pre>template &lt;class <a href="#Source">Source</a>&gt;
  path&amp; operator=(Source const&amp; source);
  template &lt;class InputIterator&gt;
  path&amp; assign(InputIterator begin, InputIterator end);</pre>
<blockquote>
  <p><i>Effects:</i> Stores the contents [<code>begin</code>,<code>end</code>) 
  or <code>source</code> in <code>pathname</code>, converting format and 
  encoding if required ([<a href="#path.arg.convert">path.arg.convert</a>]). </p>
  <p>
  <i>Returns: </i><code>*this</code></p>
  </blockquote>
<h3>1.6.6  <a name="path-appends"><code><font size="4"> path</font></code> appends</a> 
[path.append]</h3>
  <p>The append operations use <code>
  operator/=</code> to denote their semantic effect of appending <i>
  preferred-separator</i> when needed. </p>
<pre>path&amp; operator/=(const path&amp; p);</pre>
<blockquote>
  <p><i>Effects:</i></p>
  <blockquote>
    Appends <code>path::preferred_separator</code> to <code>pathname</code>, 
    converting format and encoding if required ([<a href="#path.arg.convert">path.arg.convert</a>]), unless:<ul>
    <li>an added separator 
    would be redundant, or</li>
    <li>would change an relative path to an absolute path, or</li>
    <li><code>p.empty()</code>, or</li>
    <li><code>*p.native().cbegin()</code> is a directory separator.</li>
  </ul>
    <p>Then appends <code>p.native()</code> to <code>pathname</code>.</p>
  </blockquote>
  <p><i>Returns: </i><code>*this</code></p>
</blockquote>
<pre>template &lt;class <a href="#Source">Source</a>&gt;
  path&amp; operator/=(Source const &amp; source);
  template &lt;class InputIterator&gt;
  path&amp; append(InputIterator begin, InputIterator end);</pre>
<blockquote>
  <p><i>Effects:</i></p>
  <blockquote>
    <p>Appends <code>path::preferred_separator</code> to <code>pathname</code>, converting 
    format and encoding if required ([<a href="#path.arg.convert">path.arg.convert</a>]), unless:</p>
    <ul>
    <li>an added separator 
    would be redundant, or</li>
    <li>would change an relative path to an absolute path, or</li>
    <li><code>p.empty()</code>, or</li>
    <li><code>*p.native().cbegin()</code> is a separator.</li>
  </ul>
    <p>Appends the contents [<code>begin</code>,<code>end</code>) 
  or <code>source</code> to <code>pathname</code>, converting format and 
    encoding if required ([<a href="#path.arg.convert">path.arg.convert</a>]).</p>
  </blockquote>
  <p><i>Returns: </i><code>*this</code></p>
  </blockquote>
  
<h3>1.6.7  <a name="path-concatenation"><code>path</code> concatenation</a> [path.concat]</h3>
<pre>path&amp; operator+=(const path&amp; x);
path&amp; operator+=(const string_type&amp; x);
path&amp; operator+=(const value_type* x);
path&amp; operator+=(value_type x);
template &lt;class Source&gt;
  path&amp; operator+=(Source const&amp; x);
template &lt;class charT&gt;
  path&amp; operator+=(charT x);
template &lt;class InputIterator&gt;
  path&amp; concat(InputIterator begin, InputIterator end);
template &lt;class InputIterator&gt;
  path&amp; concat(InputIterator begin, InputIterator end);</pre>
<blockquote><p><i>Postcondition:</i> <code>native() == prior_native + <i>effective-argument</i></code>,
 where <code>prior_native</code> is <code>native()</code> prior to the call to <code>operator+=</code>,
 and <code><i>effective-argument</i></code> is:</p>
 <ul><li><code>x.native()</code> if <code>x</code> is present and is <code>const path&amp;</code>, otherwise</li>
 <li><code>s</code>, where <code>s</code> is
  <code>basic_string&lt;typename iterator_traits&lt;InputIterator&gt;::value_type&gt;<br>s(begin, end)</code>,
   if <code>begin</code> and <code>end</code> arguments are present, otherwise</li>
 <li><code>x</code>.</li></ul><p>If the value type of <code><i>effective-argument</i></code> would not be <code>path::value_type</code>, the actual argument or argument range is first
   converted so that <code><i>effective-argument</i></code> has value type <code>path::value_type</code>.</li> </p>
 <p><i>Returns: </i><code>*this</code></p>
 </blockquote>
<h3>1.6.8  <a name="path-modifiers"> <code>
path</code> modifiers</a> [path.modifiers]</h3><pre>void <a name="path-clear">clear</a>() noexcept;</pre>
<blockquote>
<p><i>Postcondition:</i> <code>this-&gt;empty()</code> is true.</p>
</blockquote>
<pre>path&amp; <a name="path-make_preferred">make_preferred</a>();</pre>
<blockquote>
  <p><i>Effects: </i>Each <i>directory-separator</i> 
  is converted to <i>preferred-separator</i>.</p>
  <p><i>Returns:</i> <code>*this</code></p>
<p>[<i>Example:</i></p>
  <blockquote>
    <pre><code>path p(&quot;foo/bar&quot;);
std::cout &lt;&lt; p &lt;&lt; '\n';
</code>p.make_preferred();
<code>std::cout &lt;&lt; p &lt;&lt; '\n';</code></pre>
  </blockquote>
  <p>On an operating system where <i>preferred-separator</i> is the same as <i>
  directory-separator</i>, the output is:</p>
  <blockquote>
    <pre>&quot;foo/bar&quot;
&quot;foo/bar&quot;</pre>
  </blockquote>
  <p>On an operating system where <i>preferred-separator</i> is a backslash, the 
  output is:</p>
  <blockquote>
    <pre>&quot;foo/bar&quot;
&quot;foo\bar&quot;</pre>
  </blockquote>
  <p> <i>-- end example</i>]</p>
</blockquote>

<pre>path&amp; <a name="path-remove_filename">remove_filename</a>();</pre>
<blockquote>
  <p><i>Returns: </i>As if, <code>*this = parent_path();</code></p>
  <p>[<i>Note:</i> This function is needed to efficiently implement <code>directory_iterator</code>. It is exposed to allow additional uses. The actual 
  implementation may be much more efficient than <code>*this = parent_path()</code>&nbsp; <i>-- end 
  note</i>]</p>
</blockquote>
<pre>path&amp; <a name="path-replace_extension">replace_extension</a>(const path&amp; new_extension = path());</pre>
<blockquote>
  <p><i>Effects:</i></p>
  <ul>
    <li>Any existing <code>extension()</code> is removed from the stored path, 
    then</li>
    <li>iff
  <code>new_extension</code> is not empty and does not begin with a dot 
    character, a dot character is appended to the stored path, then</li>
    <li>
  <code>new_extension</code> is appended to the stored path.</li>
  </ul>
  <p><i>Returns:</i> <code>*this</code></p>
</blockquote>
<pre><code>void <a name="path-swap">swap</a>(path&amp; rhs)</code> noexcept<code>;</code></pre>
<blockquote>
  <p><i>Effects:</i> Swaps the contents of the two paths.</p>
  <p><i>Complexity: </i>constant time.</p>
  <p><span style="background-color: #E0E0E0"><i>See </i></span><i>
  <span class="gI"><span style="background-color: #E0E0E0">
  &nbsp;[c++std-filesystem-44] from </span></span>
  <span email="daniel.kruegler@gmail.com" name="Daniel Krügler" class="gD">
  <span style="background-color: #E0E0E0">Daniel Krügler </span></span>
  <span class="gI"><span style="background-color: #E0E0E0">for <code>noexcept</code> 
  rationale.</span></span></i></p>
</blockquote>

<h3>1.6.9   <a name="path-native-format-observers"><code>path</code> native format observers</a> 
[path.native.obs]</h3>
<p>The string returned by all native format observers is in the <a href="#fs.def.native">native pathname format</a>.</p>
<pre>const string_type&amp;  <a name="native">native</a>() const noexcept;</pre>
<blockquote>
<p><i>Returns:</i> <code>pathname</code>.</p>
</blockquote>
<pre>const value_type* <a name="c_str">c_str</a>() const noexcept;</pre>
<blockquote>
<p><i>Returns:</i> <code>pathname.c_str()</code>.</p>
</blockquote>

<pre>template &lt;class charT, class traits = char_traits&lt;charT&gt;,
          class Allocator = allocator&lt;charT&gt; &gt;
basic_string&lt;charT, traits, Allocator&gt;
  <a name="string-template">string</a>(const Allocator& a = Allocator()) const;</pre>


<blockquote>
  <p><i>Returns:</i> <code>pathname</code>.</p>
<p><i>Remarks:</i> If the return type is different from <code>string_type</code>, 
conversion is performed as specified by [<a href="#path-Conversions">path.cvt</a>]).</p>
</blockquote>
<pre>string <a name="string">string</a>() const;
wstring <a name="wstring">wstring</a>() const;
u16string <a name="u16string">u16string</a>() const;
u32string <a name="u32string">u32string</a>() const; </pre>
<blockquote>
<p><i>Returns:</i> <code>pathname</code>.</p>
<p><i>Remarks:</i> If the return type is different from <code>string_type</code>, 
conversion is performed as specified by [<a href="#path-Conversions">path.cvt</a>].</p>
</blockquote>

<h3>1.6.10   <a name="path-generic-format-observers"><code>path</code> generic format observers</a> 
[path.generic.obs]</h3>
<p>Generic format observer functions 
 
return strings formatted according to the generic pathname format ([<a href="#path.generic">path.generic</a>]). 
The forward slash (<code>'/'</code>) character is used as the <i>
directory-separator</i> character.</p>
<blockquote>
<p>[<i>Example:</i> On an operating system that uses backslash as 
its preferred-separator,&nbsp; <code>path(&quot;foo\\bar&quot;).generic_string()</code> 
returns <code>&quot;foo/bar&quot;</code>. <i>-- end example</i>]</p>
</blockquote>

<pre>template &lt;class charT, class traits = char_traits&lt;charT&gt;,
          class Allocator = allocator&lt;charT&gt; &gt;
basic_string&lt;charT, traits, Allocator&gt;
  <a name="generic_string-template">generic_string</a>(const Allocator& a = Allocator()) const;</pre>

<blockquote>
  <p><i>Returns:</i> <code>pathname</code>, reformatted according to the generic 
  pathname format ([<a href="#path.generic">path.generic</a>]). </p>
<p><i>Remarks:</i> If the return type is different from <code>string_type</code>, 
conversion is performed as specified by [<a href="#path-Conversions">path.cvt</a>].</p>
</blockquote>
<pre>string <a name="generic_string">generic_string</a>() const;
wstring <a name="generic_wstring">generic_wstring</a>() const;
u16string <a name="generic_u16string">generic_u16string</a>() const;
u32string <a name="generic_u32string">generic_u32string</a>() const; </pre>
<blockquote>
<p><i>Returns:</i> <code>pathname</code>, reformatted according to the generic 
pathname format ([<a href="#path.generic">path.generic</a>]).</p>
<p><i>Remarks:</i>&nbsp; If the return type is different from <code>string_type</code>, 
conversion is performed as specified by [<a href="#path-Conversions">path.cvt</a>].</p>
</blockquote>

<h3>1.6.11   <a name="path-compare"><code>path</code> compare</a> [path.compare]</h3>
<pre>int compare(const path&amp; p) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> A value less than 0 if the elements of <code>*this</code> are lexicographically less than the elements of <code>p</code>, otherwise a 
  value greater than 0 if the elements of <code>*this</code> are 
  lexicographically greater than the elements of <code>p</code>, otherwise 0.</p>
  <p>Remark: The elements are determined as if by iteration over the half-open 
  range [<code>begin()</code>, <code>end()</code>) for <code>*this</code> and&nbsp; <code>p</code>.</p>
</blockquote>
<pre>int compare(const string&amp; s) const</pre>
<blockquote>
  <p><i>Returns:</i> <code>compare(path(s))</code>.</p>
</blockquote>
<pre>int compare(const value_type* s) const</pre>
<blockquote>
  <p><i>Returns:</i> <code>compare(path(s))</code>.</p>
</blockquote>
<h3>1.6.12   <a name="path-decomposition"> <code>path</code> decomposition</a> 
[path.decompose]</h3>
<pre>path <a name="path-root_name">root_name</a>() const;</pre>
<blockquote>
<p><i>Returns:</i> <i>root-name,</i> if <code>pathname</code> includes <i>root-name</i>, otherwise <code>path()</code>. </p>
</blockquote>
<pre>path <a name="path-root_directory">root_directory</a>() const;</pre>
<blockquote>
<p><i>Returns:</i> <i>root-directory</i>, if <code>pathname</code> includes <i>root-directory</i>, otherwise <code>path()</code>.</p>
<p>If <i>root-directory</i> is composed of <i>slash name</i>, <i>slash</i> is 
excluded from the returned string.</p>
</blockquote>
<pre>path <a name="path-root_path">root_path</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>root_name() / root_directory()</code></p>
</blockquote>
<pre>path <a name="path-relative_path">relative_path</a>() const;</pre>
<blockquote>
<p><i>Returns:</i> A <code>path</code> composed from <code>pathname</code>, if <code>!empty()</code>, beginning 
with the first <i>filename</i> after <i>root-path</i>. Otherwise, <code>path()</code>.</p>
</blockquote>
<pre>path <a name="path-parent_path">parent_path</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>(empty() || begin() == --end()) ? path() : <i>pp</i></code>, where <code><i>pp</i></code> is constructed as if by 
  starting with an empty <code>path</code> and successively applying <code>operator/=</code> for each element in the range <code>begin()</code>, <code>--end()</code>.</p>
</blockquote>
<pre>path <a name="path-filename">filename</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>empty() ? path() : *--end()</code></p>
  <p>[<i>Example:</i></p>
  <blockquote>
    <pre><code>std::cout &lt;&lt; path(&quot;/foo/bar.txt&quot;).filename();</code> // outputs &quot;<code>bar.txt</code>&quot;</pre>
  </blockquote>
  <p> <i>--end example</i>]</p>
</blockquote>
<pre>path <a name="path-stem">stem</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> if <code>filename()</code> contains a character but does not 
  consist solely of one or to two periods, returns 
  the substring of <code>filename()</code> starting at its beginning and 
  ending with the character before the last period. Otherwise, 
  returns <code>filename()</code>.</p>
  <p>[<i>Example:</i></p>
  <blockquote>
    <pre><code>std::cout &lt;&lt; path(&quot;/foo/bar.txt&quot;).stem();</code> // outputs &quot;<code>bar</code>&quot;
path p = &quot;foo.bar.baz.tar&quot;;
for (; !p.extension().empty(); p = p.stem())
  std::cout &lt;&lt; p.extension() &lt;&lt; '\n';
  // outputs: .tar
  //          .baz
  //          .bar</pre>
  </blockquote>
  <p> <i>--end example</i>]</p>
</blockquote>
<pre>path <a name="path-extension">extension</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> if <code>filename()</code> contains a period but does not 
  consist solely of one or to two periods, returns 
  the substring of <code>filename()</code> starting at the rightmost period 
  and for the remainder of the path. Otherwise, returns an empty <code>path</code> object. </p>
  <p><i>Remarks:</i> Implementations are permitted to define additional 
  behavior for file systems which append additional elements to extensions, such 
  as alternate data streams or partitioned dataset names.</p>
  <p>[<i>Example:</i></p>
  <blockquote>
    <pre><code>std::cout &lt;&lt; path(&quot;/foo/bar.txt&quot;).extension(); //</code> outputs &quot;<code>.txt</code>&quot;</pre>
  </blockquote>
  <p> <i>--end example</i>]</p>
  <p>[<i>Note:<b> </b></i>The period is included in the return value so that it is 
  possible to distinguish between no extension and an empty extension. Also note 
  that for a path <code>p</code>, <code>p.stem()+p.extension() == p</code>. <i>
  -- end note</i>]</p>
</blockquote>
<h3>1.6.13   <a name="path-query"> <code>path</code> query</a> [path.query]</h3>
<pre>bool <a name="path-empty">empty</a>() const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_pathname.empty()</code>.</p>
</blockquote>
<pre>bool <a name="path-has_root_path">has_root_path</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!<a href="#path-root_path">root_path</a>().empty()</code></p>
</blockquote>
<pre>bool <a name="path-has_root_name">has_root_name</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!<a href="#path-root_name">root_name</a>().empty()</code></p>
</blockquote>
<pre>bool <a name="path-has_root_directory">has_root_directory</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!<a href="#path-root_directory">root_directory</a>().empty()</code></p>
</blockquote>
<pre>bool <a name="path-has_relative_path">has_relative_path</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!<a href="#path-has_relative_path">relative_path</a>().empty()</code></p>
</blockquote>
<pre>bool <a name="path-has_parent_path">has_parent_path</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!<a href="#path-parent_path">parent_path</a>().empty()</code></p>
</blockquote>
<pre>bool <a name="path-has_filename">has_filename</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!<a href="#path-filename">filename</a>().empty()</code></p>
</blockquote>
<pre>bool <a name="path-has_stem">has_stem</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!<a href="#path-stem">stem</a>().empty()</code></p>
</blockquote>
<pre>bool <a name="path-has_extension">has_extension</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!<a href="#path-has_extension">extension</a>().empty()</code></p>
</blockquote>
<pre>bool <a name="path-is_absolute">is_absolute</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>true</code> if the elements of <code>root_path()</code> uniquely identify a 
  file system location, else <code>false</code>.</p>
</blockquote>
<blockquote>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse"
   bordercolor="#111111" width="90%" bgcolor="#E8FFE8">
    <tr>
      <td width="100%">[<i>Example:</i> <code>path(&quot;/&quot;).is_absolute()</code> is
      <code>true</code> for ISO 
9945/POSIX based operating systems, and <code>false</code> for Windows based 
operating systems.&nbsp; <i>--end example</i>]</td>
    </tr>
  </table>
</blockquote>
<pre>bool <a name="path-is_relative">is_relative</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!is_absolute()</code>.</p>
</blockquote>
<h3>1.6.14   <a name="path-iterators"> <code>
path</code> iterators</a> [path.itr]</h3>
<p> Path iterators iterate over the elements of the stored pathname.</p>
<p> A <code>path::iterator</code> is a constant iterator satisfying all 
the requirements of a bidirectional iterator (C++ Std, 24.1.4 Bidirectional 
iterators [lib.bidirectional.iterators]). Its <code>value_type</code> is <code>path</code>.</p>
  <p>Calling any non-const member function of a <code>path</code> object 
  invalidates all iterators referring to elements of that object.</p>
<p> The forward traversal order is as follows:</p>
<ul>
  <li>The <i>root-name</i> element, if present.</li>
  <li>The <i>root-directory</i> element, if present, in the generic format. <i>
  [note:</i> the generic format is required to ensure lexicographical 
  comparison works correctly. <i>-- end note</i>]</li>
  <li>Each successive <i>filename</i> element, if present.</li>
  <li><i>Dot</i>, if one or more trailing non-root <i>slash</i> 
  characters are present.</li>
</ul>
  <p>The backward traversal order is the reverse of forward traversal.</p>
  <pre>iterator begin() const;</pre>
<blockquote>
  <p><i>Returns:</i> An iterator for the first present element in the traversal 
  list above. If no elements are present, the end iterator.</p>
</blockquote>
<pre>iterator end() const;</pre>
<blockquote>
  <p><i>Returns:</i> The end iterator.</p>
</blockquote>
 <p><h3>1.6.15   <a name="path-non-member-functions"> <code>path</code> non-member functions</a> 
[path.non-member]</h3>
<pre>void swap(path&amp; lhs, path&amp; rhs) noexcept;</pre>
<blockquote>
  <p><i>Effects: </i><code>lhs.swap(rhs)</code>.</p>
</blockquote>
<pre>size_t <a name="hash_value">hash_value</a> (const path&amp; p) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> A hash value for the path <code>p</code>. If
  for two paths, <code>p1 == p2</code> then <code>hash_value(p1) == hash_value(p2)</code>.</p>
</blockquote>
<pre>bool operator&lt; (const path&amp; lhs, const path&amp; rhs) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>return lhs.compare(rhs) &lt; 0</code>.</p>
</blockquote>
<pre>bool operator&lt;=(const path&amp; lhs, const path&amp; rhs) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!(rhs &lt; lhs)</code>.</p>
</blockquote>
<pre>bool operator&gt; (const path&amp; lhs, const path&amp; rhs) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>rhs &lt; lhs</code>.</p>
</blockquote>
<pre>bool operator&gt;=(const path&amp; lhs, const path&amp; rhs) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!(lhs &lt; rhs)</code>.</p>
</blockquote>
<pre>bool operator==(const path&amp; lhs, const path&amp; rhs) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!(lhs &lt; rhs) &amp;&amp; !(rhs &lt; lhs)</code>.</p>
  <p>[<i>Note:</i> <a name="Path-equality">Path equality</a> and path 
  equivalence have different semantics.</p>
  <p>Equality is determined by the <code>path</code> non-member <code>operator==</code>, which considers the two path's lexical 
  representations only. Thus <code>path(&quot;foo&quot;) == &quot;bar&quot;</code> is never <code>true</code>.</p>
  <p>Equivalence is determined by the <a href="#equivalent"><code>equivalent()</code></a> non-member function, which determines if two paths <a href="#class-path">resolve</a> to the same file system entity. 
  Thus <code>equivalent(&quot;foo&quot;, &quot;bar&quot;)</code> will be <code>true</code> when both paths resolve to the same file.</p>
  <p>Programmers wishing to determine if two paths are &quot;the same&quot; must decide if 
  &quot;the same&quot; means &quot;the same representation&quot; or &quot;resolve to the same actual 
  file&quot;, and choose the appropriate function accordingly. <i>-- end note</i>]</p>
</blockquote>
<pre>bool operator!=(const path&amp; lhs, const path&amp; rhs) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!(lhs == rhs)</code>.</p>
</blockquote>
<pre>path operator/ (const path&amp; lhs, const path&amp; rhs);</pre>
<blockquote>
  <p><i>Returns:</i> <code>path(lhs) /= rhs</code>.</p>
</blockquote>
<h3>1.6.16  <code>path</code><a name="path-inserter-extractor"> inserter 
  and extractor</a> [path.io]</h3>
<pre>template &lt;class charT, class traits&gt;
basic_ostream&lt;charT, traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const path&amp; p);</pre>
<blockquote>
  <p><i>Effects:</i> <code>os &lt;&lt; p.string&lt;charT, traits&gt;()</code>.</p>
  <p>[<i>Note:</i> Pathnames containing spaces require special handling by the 
  user to avoid truncation when read by the extractor. <i>--end note</i>]</p>
  <p><span style="background-color: #E0E0E0"><i>The Boost inserter outputs 
  quoted strings, which are recognized as such by the extractor. There was 
  sentiment within the Filesystem Study Group that supplying a quoted and/or 
  escaped string manipulator as a string extension was a better solution than a 
  path specific feature. </i></span></p>
  <p><i>Returns:</i> <code>os</code></p>
  </blockquote>
<pre>template &lt;class charT, class traits&gt;
basic_istream&lt;charT, traits&gt;&amp;
operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, path&amp; p);</pre>
<blockquote>
  <p><i>Effects:&nbsp; </i></p>
  <blockquote>
    <pre>basic_string&lt;charT, traits&gt; tmp;
is &gt;&gt; tmp;
p = tmp;</pre>
  </blockquote>
  <p><i>Returns:</i> <code>is</code></p>
  </blockquote>
<h2>1.7  <a name="Class-filesystem_error">Class <code>filesystem_error</code> 
[class.filesystem_error]</a></h2>
<pre>namespace std { namespace tbd { namespace filesystem {

      class filesystem_error : public system_error
      {
      public:
        <a href="#filesystem_error-2-arg">filesystem_error</a>(const string&amp; what_arg, error_code ec);
        <a href="#filesystem_error-3-arg">filesystem_error</a>(const string&amp; what_arg,
          const path&amp; p1, error_code ec);
        <a href="#filesystem_error-4-arg">filesystem_error</a>(const string&amp; what_arg,
          const path&amp; p1, const path&amp; p2, error_code ec);

        const path&amp; <a href="#filesystem_error-path1">path1</a>() const noexcept;
        const path&amp; <a href="#filesystem_error-path2">path2</a>() const noexcept;
        const char* <a href="#filesystem_error-what">what</a>() const noexcept;
      };
} } }  // namespaces std::tbd::filesystem</pre>
<p>The class template <code>filesystem_error</code> defines the type of 
objects thrown as exceptions to report file system errors from functions described in this 
clause.</p>
<h3>1.7.1   <a name="filesystem_error-members"> <code>filesystem_error</code> members</a> 
[filesystem_error.members]</h3>
<p> Constructors are provided that store zero, one, or two paths associated with 
an error.</p>
<pre><a name="filesystem_error-2-arg">filesystem_error</a>(const string&amp; what_arg, error_code ec);</pre>
<blockquote>
  <p><i>Postcondition:</i></p>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="46%">
    <tr>
      <td width="18%"><b>Expression</b></td>
      <td width="82%"><b>Value</b></td>
    </tr>
    <tr>
      <td width="18%" bgcolor="#FFFFFF"><code>
      runtime_error::what()</code></td>
      <td width="82%" bgcolor="#FFFFFF">
      <code>what_arg.c_str()</code></td>
    </tr>
    <tr>
      <td width="18%"><code>code()</code></td>
      <td width="82%"><code>ec</code></td>
    </tr>
    <tr>
      <td width="18%"><code>path1().empty()</code></td>
      <td width="82%"><code>true</code></td>
    </tr>
    <tr>
      <td width="18%"><code>path2().empty()</code></td>
      <td width="82%"><code>true</code></td>
    </tr>
  </table>
</blockquote>
<pre><a name="filesystem_error-3-arg">filesystem_error</a>(const string&amp; what_arg, const path_type&amp; p1, error_code ec);</pre>
<blockquote>
  <p><i>Postcondition:</i></p>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="46%">
    <tr>
      <td width="18%"><b>Expression</b></td>
      <td width="82%"><b>Value</b></td>
    </tr>
    <tr>
      <td width="18%" valign="top"><code>
      runtime_error::what()</code></td>
      <td width="82%">
      <code>what_arg.c_str()</code></td>
    </tr>
    <tr>
      <td width="18%" valign="top"><code>code()</code></td>
      <td width="82%"><code>ec</code></td>
    </tr>
    <tr>
      <td width="18%" valign="top"><code>path1()</code></td>
      <td width="82%">Reference to stored copy of <code>p1</code></td>
    </tr>
    <tr>
      <td width="18%" valign="top"><code>path2().empty()</code></td>
      <td width="82%"><code>true</code></td>
    </tr>
  </table>
</blockquote>
<pre><a name="filesystem_error-4-arg">filesystem_error</a>(const string&amp; what_arg, const path_type&amp; p1, const path_type&amp; p2, error_code ec);</pre>
<blockquote>
  <p><i>Postcondition:</i></p>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="46%">
    <tr>
      <td width="18%"><b>Expression</b></td>
      <td width="82%"><b>Value</b></td>
    </tr>
    <tr>
      <td width="18%"><code>
      runtime_error::what()</code></td>
      <td width="82%">
      <u>
      <code>w</code></u><code>hat_arg.c_str()</code></td>
    </tr>
    <tr>
      <td width="18%"><code>code()</code></td>
      <td width="82%"><code>ec</code></td>
    </tr>
    <tr>
      <td width="18%"><code>path1()</code></td>
      <td width="82%">Reference to stored copy of <code>p1</code></td>
    </tr>
    <tr>
      <td width="18%"><code>path2()</code></td>
      <td width="82%">Reference to stored copy of <code>p2</code></td>
    </tr>
  </table>
</blockquote>
<pre>const path&amp; <a name="filesystem_error-path1">path1</a>() const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> Reference to copy of <code>p1</code> stored by the 
  constructor, or, if none, an empty path.</p>
</blockquote>
<pre>const path&amp; <a name="filesystem_error-path2">path2</a>() const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> Reference to copy of <code>p2</code> stored by the 
  constructor, or, if none, an empty path.</p>
</blockquote>
<pre>const char* <a name="filesystem_error-what">what</a>() const noexcept;</pre>
<blockquote>
  <p><i>Returns: </i>A string containing <code>runtime_error::what()</code>. The exact format is unspecified. 
  Implementations are encouraged but not required to include <code>path1.native_string()</code>if not empty, <code>path2.native_string()</code>if 
  not empty, and <code>system_error::what()</code> strings in the returned 
  string.</p>
</blockquote>
<h2>1.8  <a name="Enum-file_type">Enum class file_type</a> [enum.file_type]</h2>
<p>This enum class specifies constants used to identify file types.</p>
<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
  <tr>
    <td><b>Constant Name</b></td>
    <td><b>Value</b></td>
    <td><b>Meaning</b></td>
  </tr>
  <tr>
    <td><code>none</code></td>
    <td align="center"><code>0</code></td>
    <td>The type of the file has not been determined or an error occurred while 
    trying to determine the type. </td>
  </tr>
  <tr>
    <td><code>not_found</code></td>
    <td align="center"><code>-1</code></td>
    <td>Pseudo-type indicating the file was not found. [<i>Note:</i> The file 
    not being found is not considered an error while determining the 
    type of a file. <i>--end note</i>]</td>
  </tr>
  <tr>
    <td><code>regular</code></td>
    <td align="center"><code>1</code></td>
    <td>Regular file</td>
  </tr>
  <tr>
    <td><code>directory</code></td>
    <td align="center"><code>2</code></td>
    <td>Directory file</td>
  </tr>
  <tr>
    <td><code>symlink</code></td>
    <td align="center"><code>3</code></td>
    <td>Symbolic link file</td>
  </tr>
  <tr>
    <td><code>block</code></td>
    <td align="center"><code>4</code></td>
    <td>Block special file</td>
  </tr>
  <tr>
    <td><code>character</code></td>
    <td align="center"><code>5</code></td>
    <td>Character special file</td>
  </tr>
  <tr>
    <td><code>fifo</code></td>
    <td align="center"><code>6</code></td>
    <td>FIFO or pipe file</td>
  </tr>
  <tr>
    <td><code>socket</code></td>
    <td align="center"><code>7</code></td>
    <td>Socket file</td>
  </tr>
  <tr>
    <td><code>unknown</code></td>
    <td align="center"><code>8</code></td>
    <td>The file does exist, but is of an operating system dependent type not 
    covered by any of the other cases or the process does not have permission to 
    query the file type</td>
  </tr>
</table>
<h2>1.9  Enum class copy_options [<a name="enum.copy_options">enum.copy_options</a>]</h2>
<p>This enumeration specifies bitmask constants used to control the semantics of 
copy operations.&nbsp; The constants are specified in option groups. Constant
<code>none</code> is shown in each option group for purposes of exposition; 
implementations shall provide only a single definition.&nbsp; Calling a 
Filesystem library function with more than a single constant for any option 
group results in undefined behavior. <i>-- end note</i>]</p>
<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
  <tr>
    <td colspan="3">
    <p align="center"><b>Option group controlling <code>copy_file</code> effects 
    when the target file already exists</b></td>
  </tr>
  <tr>
    <td><b>Constant</b></td>
    <td><b>Value</b></td>
    <td><b>Meaning</b></td>
  </tr>
  <tr>
    <td><code>none</code></td>
    <td align="center"><code>0</code></td>
    <td>(Default) Error; file already exists.</td>
  </tr>
  <tr>
    <td><code>skip</code></td>
    <td align="center"><code>1</code></td>
    <td>Do not overwrite existing file, do not report an error.</td>
  </tr>
  <tr>
    <td><code>overwrite</code></td>
    <td align="center"><code>2</code></td>
    <td>Overwrite the existing file.</td>
  </tr>
  <tr>
    <td><code>update</code></td>
    <td align="center"><code>4</code></td>
    <td>Overwrite the existing file if it is older than the replacement file.</td>
  </tr>
  <tr>
    <td colspan="3">
    <p align="center"><b>Option group controlling <code>copy</code> effects for 
    sub-directories</b></td>
  </tr>
  <tr>
    <td><b>Constant</b></td>
    <td><b>Value</b></td>
    <td><b>Meaning</b></td>
  </tr>
  <tr>
    <td><code>none</code></td>
    <td align="center"><code>0</code></td>
    <td>(Default) Do not copy sub-directories.</td>
  </tr>
  <tr>
    <td><code>recursive</code></td>
    <td align="center"><code>8</code></td>
    <td>Recursively copy sub-directories and their contents.</td>
  </tr>
  <tr>
    <td colspan="3">
    <p align="center"><b>Option group controlling <code>copy</code> effects for 
    symbolic links</b></td>
  </tr>
  <tr>
    <td><b>Constant</b></td>
    <td><b>Value</b></td>
    <td><b>Meaning</b></td>
  </tr>
  <tr>
    <td><code>none</code></td>
    <td>
    <p align="center"><code>0</code></td>
    <td>(Default) Follow symbolic links.</td>
  </tr>
  <tr>
    <td><code>copy_symlinks</code></td>
    <td>
    <p align="center"><code>16</code></td>
    <td>Copy symbolic links as symbolic links rather than copying the files that 
    they point to.</td>
  </tr>
  <tr>
    <td><code>skip_symlinks</code></td>
    <td>
    <p align="center"><code>32</code></td>
    <td>Ignore symbolic links.</td>
  </tr>
  <tr>
    <td colspan="3">
    <p align="center"><b>Option group controlling <code>copy</code> effects 
    choosing the form of copying</b></td>
  </tr>
  <tr>
    <td><b>Constant</b></td>
    <td><b>Value</b></td>
    <td><b>Meaning</b></td>
  </tr>
  <tr>
    <td><code>none</code></td>
    <td>
    <p align="center"><code>0</code></td>
    <td>(Default) Copy content.</td>
  </tr>
  <tr>
    <td><code>structure_only</code></td>
    <td>
    <p align="center"><code>64</code></td>
    <td>Copy directory structure only, do not copy non-directory files.</td>
  </tr>
  <tr>
    <td><code>make_symlinks</code></td>
    <td>
    <p align="center"><code>128</code></td>
    <td>Make symbolic links instead of copies of files. The source path shall be 
    an absolute path unless the destination path is in the current directory.</td>
  </tr>
  <tr>
    <td><code>make_hard_links</code></td>
    <td>
    <p align="center"><code>256</code></td>
    <td>Make hard links instead of copies of files.</td>
  </tr>
</table>
<h2>1.10  <a name="Enum-perms">Enum perms</a> [enum.perms]</h2>
<p>This enumeration specifies bitmask constants used to identify file 
permissions. <i><span style="background-color: #E0E0E0">ISO/</span><span style="background-color: #E0E0E0">IEC</span><span style="background-color: #E0E0E0"> 9945 
(POSIX) specifies actual values, and those values have been adopted here because 
they are very familiar and ingrained for many  users.</span></i></p>
<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
  <tr>
    <td><b>Name</b></td>
    <td align="center"><b>Value<br>
    (octal)</b></td>
    <td align="center"><b>ISO/IEC 9945<br>
    macro</b></td>
    <td><b>Definition or notes</b></td>
  </tr>

<tr><td>
  <p><code>no_perms</code></td><td><code>0</code></td><td></td>
  <td>There are no permissions set for the file. Note: <code>
  file_type::not_found</code> is <code>no_perms</code> rather than <code>perms_not_known</code></td>
</tr>
<tr><td><code>owner_read</code></td><td><code>0400</code></td><td> <code>S_IRUSR</code></td>
  <td> Read permission, owner</td>
</tr>
<tr><td><code>owner_write</code></td><td><code>0200</code></td><td> <code>S_IWUSR</code></td>
  <td> Write permission, owner</td>
</tr>
<tr><td><code>owner_exe</code></td><td><code>0100</code></td><td>  <code>S_IXUSR</code></td>
  <td> Execute/search permission, owner</td>
</tr>
<tr><td><code>owner_all</code></td><td><code>0700</code></td><td>  <code>S_IRWXU</code></td>
  <td> Read, write, execute/search by owner; <code>owner_read | owner_write | owner_exe</code></td>
</tr>
<tr><td><code>group_read</code></td><td><code>040</code></td><td>  <code>S_IRGRP</code></td>
  <td> Read permission, group</td>
</tr>
<tr><td><code>group_write</code></td><td><code>020</code></td><td> <code>S_IWGRP</code></td>
  <td> Write permission, group</td>
</tr>
<tr><td><code>group_exe</code></td><td><code>010</code></td><td>   <code>S_IXGRP</code></td>
  <td> Execute/search permission, group</td>
</tr>
<tr><td><code>group_all</code></td><td><code>070</code></td><td>   <code>S_IRWXG</code></td>
  <td> Read, write, execute/search by group; <code>group_read | group_write | group_exe</code></td>
</tr>
<tr><td><code>others_read</code></td><td><code>04</code></td><td>  <code>S_IROTH</code></td>
  <td> Read permission, others</td>
</tr>
<tr><td><code>others_write</code></td><td><code>02</code></td><td> <code>S_IWOTH</code></td>
  <td> Write permission, others</td>
</tr>
<tr><td><code>others_exe</code></td><td><code>01</code></td><td>   <code>S_IXOTH</code></td>
  <td> Execute/search permission, others</td>
</tr>
<tr><td><code>others_all</code></td><td><code>07</code></td><td>   <code>S_IRWXO</code></td>
  <td>Read, write, execute/search by others; <code>others_read | others_write | others_exe</code></td>
</tr>
<tr><td><code>all_all</code></td><td><code>0777</code></td><td> </td><td><code>owner_all | group_all | others_all</code></td>
</tr>
<tr><td><code>set_uid_on_exe</code></td><td><code>04000</code></td><td> <code>S_ISUID</code></td>
  <td> Set-user-ID on execution</td>
</tr>
<tr><td><code>set_gid_on_exe</code></td><td><code>02000</code></td><td> <code>S_ISGID</code></td>
  <td> Set-group-ID on execution</td>
</tr>
<tr><td><code><a name="sticky_bit">sticky_bit</a> </code></td><td><code>01000</code></td><td> <code>S_ISVTX</code></td>
  <td> Operating system dependent. Inherently non-portable, even between ISO/IEC 9945 
  operating systems.</td>
</tr>
<tr><td><code><a name="perms_mask">perms_mask</a></code></td><td><code>07777</code></td><td> &nbsp;</td>
  <td><code>all_all | set_uid_on_exe | set_gid_on_exe | sticky_bit</code></td>
</tr>
<tr><td><code>perms_not_known</code></td><td><code>0xFFFF</code></td><td></td><td> 
  The permissions are not known, such as when a <code>file_status</code> object 
  is created without specifying the permissions</td>
</tr>
<tr><td>
  <p><code>add_perms</code></td><td><code>0x1000</code></td><td></td><td>
  <p><code>permissions()</code> adds the argument permission bits to the 
  file's current bits</td>
</tr>
<tr><td><code>remove_perms</code></td><td><code>0x2000</code></td><td></td><td>
  <code>permissions()</code> removes the argument permission bits from the 
  file's current bits</td>
</tr>
<tr><td><code><a name="symlink_perms">symlink_perms</a></code></td><td><code>0x4000</code></td><td></td><td>
  <span style="background-color: #E8FFE8">ISO-9945/POSIX </span> <code>
  <span style="background-color: #E8FFE8">permissions()</span></code><span style="background-color: #E8FFE8"> resolves symlinks unless
  </span> <code><span style="background-color: #E8FFE8">symlink_perms</span></code><span style="background-color: #E8FFE8"> is specified. 
  Meaningless on Windows as </span> <code>
  <span style="background-color: #E8FFE8">permissions()</span></code><span style="background-color: #E8FFE8"> never resolves symlinks. 
  Meaningless on Mac OS X and some other BSD systems as </span> <code>
  <span style="background-color: #E8FFE8">permissions()</span></code><span style="background-color: #E8FFE8"> always resolves symlinks. Get over it.</span></td>
</tr>

</table>
<p><i><span style="background-color: #E0E0E0">Windows: All permissions except 
write are currently ignored. There is only a single write permission; setting 
write permission for owner, group, or others sets write permission for all, and 
removing write permission for owner, group, or others removes write permission 
for all. The Cygwin users guide has extensive discussion of the problems 
involved. Input from security experts is needed.</span></i></p>
<h2>1.11  <a name="file_status">Class file_status</a> [class.file_status]</h2>
<pre>namespace std { namespace tbd { namespace filesystem {

      class file_status
      {
      public:

        // <a href="#file_status-constructors">constructors</a>
        explicit file_status(<a href="#file_type">file_type</a> ft = file_type::none,
                             <a href="#Enum-perms">perms</a> prms = perms_not_known) noexcept;
        file_status(const file_status&amp;) noexcept = default;
        file_status(file_status&amp;&amp;) noexcept = default;
       ~file_status() = default;

        file_status&amp; operator=(const file_status&amp;) noexcept = default;
        file_status&amp; operator=(file_status&amp;&amp;) noexcept = default;

        // <a href="#file_status-observers">observers</a>
        <a href="#file_type">file_type</a>  type() const noexcept;
        <a href="#Enum-perms">perms</a>      permissions() const noexcept;

        // <a href="#file_status-modifiers">modifiers</a>
        void       type(<a href="#file_type">file_type</a> ft) noexcept;
        void       permissions(<a href="#Enum-perms">perms</a> prms) noexcept;
      };
} } }  // namespaces std::tbd::filesystem</pre>
<p>An object of type <code>file_status</code> stores information about the type 
and permissions of a file.</p>
<h3>1.11.1  <a name="file_status-constructors"><code>file_status</code> constructors</a> 
[file_status.cons]</h3>
<pre>explicit file_status() noexcept;</pre>
<blockquote>
  <p><i>Postconditions:</i> <code>type() == file_type::none</code>, <code>permissions() == perms_not_known</code>.</p>
</blockquote>
<pre>explicit file_status(<a href="#file_type">file_type</a> ft, <a href="#Enum-perms">perms</a> prms = perms_not_known) noexcept;</pre>
<blockquote>
  <p><i>Postconditions:</i> <code>type() == ft</code>, <code>permissions() == prms</code>.</p>
</blockquote>
  <h3>1.11.2  <a name="file_status-observers"><code>file_status</code> observers</a> [file_status.obs]</h3>
<pre><a href="#file_type">file_type</a> type() const noexcept;</pre>
<blockquote>
  <p><i>Returns: </i>The value of <code>type()</code> specified by the <i>postconditions</i> of the most recent call to a constructor, operator=, or <code>type(file_type)</code> function.</p>
</blockquote>
<pre><a href="#Enum-perms">perms</a> permissions() const noexcept;</pre>
<blockquote>
  <p><i>Returns: </i>The value of <code>permissions()</code> specified by the <i>postconditions</i> of the most recent call to a constructor, operator=, or <code>permissions(perms)</code> function.</p>
</blockquote>
<h3>1.11.3  <a name="file_status-modifiers"><code>file_status</code> modifiers</a> [file_status.mods]</h3>
<pre>void type(<a href="#file_type">file_type</a> ft) noexcept;</pre>
<blockquote>
  <p><i>Postconditions:</i> <code>type() == ft</code>.</p>
</blockquote>
<pre>void permissions(<a href="#Enum-perms">perms</a> prms) noexcept;</pre>
<blockquote>
  <p><i>Postconditions:</i> <code>permissions() == prms</code>.</p>
</blockquote>
<h2>1.12  <a name="Class-directory_entry">Class <code>directory_entry</code></a> [class.directory_entry]</h2>
<pre>namespace std { namespace tbd { namespace filesystem {

      class directory_entry
      {
      public:

        // <a href="#directory_entry-constructors">constructors</a> and destructor
        directory_entry() noexcept = default;
        directory_entry(const directory_entry&amp;) = default;
        directory_entry(directory_entry&amp;&amp;) noexcept = default;
        explicit directory_entry(const path_type&amp; p, file_status st=file_status(),
          file_status symlink_st=file_status());
       ~directory_entry() = default; 

        // <a href="#directory_entry-modifiers">modifiers</a>
        directory_entry&amp; operator=(const directory_entry&amp;) = default;
        directory_entry&amp; operator=(directory_entry&amp;&amp;) noexcept = default;
        void assign(const path_type&amp; p, file_status st=file_status(),
          file_status symlink_st=file_status());
        void replace_filename(const path&amp; p, file_status st=file_status(),
          file_status symlink_st=file_status());

        // <a href="#directory_entry-observers">observers</a>
        const path&amp;  path() const noexcept;
        file_status  status() const;
        file_status  status(error_code&amp; ec) const noexcept;
        file_status  symlink_status() const;
        file_status  symlink_status(error_code&amp; ec) const noexcept;

        bool operator&lt; (const directory_entry&amp; rhs) const noexcept;
        bool operator==(const directory_entry&amp; rhs) const noexcept; 
        bool operator!=(const directory_entry&amp; rhs) const noexcept; 
        bool operator&lt; (const directory_entry&amp; rhs) const noexcept;
        bool operator&lt;=(const directory_entry&amp; rhs) const noexcept;
        bool operator&gt; (const directory_entry&amp; rhs) const noexcept;
        bool operator&gt;=(const directory_entry&amp; rhs) const noexcept;
      private:
        path_type            m_path;           // for exposition only
        mutable file_status  m_status;         // for exposition only; stat()-like
        mutable file_status  m_symlink_status; // for exposition only; lstat()-like
      };

} } }  // namespaces std::tbd::filesystem</pre>
<p>A <code>directory_entry</code> object stores a <code>path object</code>, 
a <code>file_status</code> object for non-symbolic link status, and a <code>file_status</code> object for symbolic link status. The <code>file_status</code> objects act as value caches.</p>
<blockquote>
<p>[<i>Note:</i> Because <code>status()</code>on a pathname may be a relatively expensive operation, 
some operating systems provide status information as a byproduct of directory 
iteration. Caching such status information can result in significant time savings. Cached and 
non-cached results may differ in the presence of file system races. <i>-- end note</i>]</p>
</blockquote>
<h3>1.12.1   <a name="directory_entry-constructors"> <code>directory_entry </code>constructors</a> 
[directory_entry.cons]</h3>
<pre>explicit directory_entry(const path_type&amp; p, file_status st=file_status(),
                         file_status symlink_st=file_status());</pre>
<blockquote>
  <p><i>Postcondition:</i></p>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="36%">
    <tr>
      <td width="18%"><b>Expression</b></td>
      <td width="82%"><b>Value</b></td>
    </tr>
    <tr>
      <td width="18%"><code>path()</code></td>
      <td width="82%"><code>p</code></td>
    </tr>
    <tr>
      <td width="18%"><code>status()</code></td>
      <td width="82%"><code>st</code></td>
    </tr>
    <tr>
      <td width="18%"><code>symlink_status()</code></td>
      <td width="82%"><code>symlink_st</code></td>
    </tr>
  </table>
</blockquote>
<h3>1.12.2   <a name="directory_entry-modifiers"> <code>directory_entry </code>modifiers</a> 
[directory_entry.mods]</h3>
<pre>void assign(const path_type&amp; p, file_status st=file_status(),
            file_status symlink_st=file_status());</pre>
<blockquote>
  <p><i>Postcondition:</i></p>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="36%">
    <tr>
      <td width="18%"><b>Expression</b></td>
      <td width="82%"><b>Value</b></td>
    </tr>
    <tr>
      <td width="18%"><code>path()</code></td>
      <td width="82%"><code>p</code></td>
    </tr>
    <tr>
      <td width="18%"><code>status()</code></td>
      <td width="82%"><code>st</code></td>
    </tr>
    <tr>
      <td width="18%"><code>symlink_status()</code></td>
      <td width="82%"><code>symlink_st</code></td>
    </tr>
  </table>
</blockquote>
<pre>void replace_filename(const path&amp; p, file_status st=file_status(),
                      file_status symlink_st=file_status());</pre>
<blockquote>
  <p><i>Postcondition:</i></p>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="43%">
    <tr>
      <td width="18%"><b>Expression</b></td>
      <td width="82%"><b>Value</b></td>
    </tr>
    <tr>
      <td width="18%"><code>path()</code></td>
      <td width="82%"><code>path().branch() / s</code></td>
    </tr>
    <tr>
      <td width="18%"><code>status()</code></td>
      <td width="82%"><code>st</code></td>
    </tr>
    <tr>
      <td width="18%"><code>symlink_status()</code></td>
      <td width="82%"><code>symlink_st</code></td>
    </tr>
  </table>
</blockquote>
<h3>1.12.3   <a name="directory_entry-observers"> <code>directory_entry</code> observers</a> 
[directory_entry.obs]</h3>
<pre>const path&amp; path() const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path</code></p>
</blockquote>
<pre>file_status status() const;
file_status status(error_code&amp; ec) const noexcept;</pre>
<blockquote>
<p><i>Effects:</i> As if,</p>
  <blockquote>
    <pre>if (!status_known(m_status))
{
  if (status_known(m_symlink_status) &amp;&amp; !is_symlink(m_symlink_status))
    { m_status = m_symlink_status; }
  else { m_status = status(m_path<i>[, ec]</i>); }
}</pre>
  </blockquote>
  <p><i>Returns:</i> <code>m_status</code></p>
  
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
  
</blockquote>
<pre>file_status  symlink_status() const;
file_status  symlink_status(error_code&amp; ec) const noexcept;</pre>
<blockquote>
<p>
  <i>Effects:</i> As if,</p>
  <blockquote>
    <pre>if (!status_known(m_symlink_status))
{
  m_symlink_status = symlink_status(m_path<i>[, ec]</i>);
}</pre>
  </blockquote>
  <p><i>Returns:</i> <code>m_symlink_status</code></p>
  
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
  
</blockquote>
<pre>bool operator==(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path == rhs.m_path</code>.</p>
</blockquote>
<pre>bool operator!=(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path != rhs.m_path</code>.</p>
</blockquote>
<pre>bool operator&lt; (const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path &lt; rhs.m_path</code>.</p>
</blockquote>
<pre>bool operator&lt;=(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path &lt;= rhs.m_path</code>.</p>
</blockquote>
<pre>bool operator&gt; (const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path &gt; rhs.m_path</code>.</p>
</blockquote>
<pre>bool operator&gt;=(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path &gt;= rhs.m_path</code>.</p>
</blockquote>
<h2>1.13  <a name="Class-directory_iterator">Class <code>directory_iterator</code> 
[class.directory_iterator]</a></h2>
<p>An object of type <code>directory_iterator</code> provides an iterator for a 
sequence of <code>directory_entry</code> elements representing the files in a 
directory.&nbsp; 
[<i>Note:</i> For iteration into sub-directories,&nbsp; see class <code><a href="#Class-recursive_directory_iterator">recursive_directory_iterator</a></code> 
([class.rec.dir.itr]). <i>--end note</i>]</p>
<pre>namespace std { namespace tbd { namespace filesystem {

      class directory_iterator :
        public iterator&lt;input_iterator_tag, directory_entry&gt;
      {
      public:
        // <a href="#directory_iterator-members">member functions</a>
        directory_iterator() noexcept;
        explicit directory_iterator(const path&amp; p);
        directory_iterator(const path&amp; p, error_code&amp; ec) noexcept;
        directory_iterator(const directory_iterator&amp;) = default;
        directory_iterator(directory_iterator&amp;&amp;) = default;
       ~directory_iterator() = default;

        directory_iterator&amp; operator=(const directory_iterator&amp;) = default;
        directory_iterator&amp; operator=(directory_iterator&amp;&amp;) = default;

        const directory_entry&amp; operator*() const;
        const directory_entry* operator-&gt;() const;
        directory_iterator&amp;    operator++();
        directory_iterator&amp;    increment(error_code&amp; ec) noexcept;

        // other members as required by
        //  C++ Std, 24.1.1 Input iterators [input.iterators]
      };

} } }  // namespaces std::tbd::filesystem</pre>
<p> <code>directory_iterator</code> satisfies the requirements of an input 
iterator ([input.iterators]).</p>
<p>If an iterator of type <code>directory_iterator</code> is advanced past the 
last directory element, that iterator shall become equal to the end iterator 
value. The <code>directory_iterator</code> default constructor&nbsp;shall 
create an iterator equal to the end iterator value, and this shall be the only 
valid iterator for the end condition. </p>
<p>The result of <code>operator*</code> on an end iterator is undefined behavior. For any other iterator value 
a <code>const directory_entry&amp;</code> is returned. The result of <code>operator-&gt;</code> on an end iterator is 
undefined behavior. For any other iterator value a <code>const directory_entry*</code> is 
returned.</p>
<p>Two end iterators are always equal. An end iterator shall not be equal to a non-end 
iterator.</p>
<blockquote>
<p><i><span style="background-color: #E0E0E0">The above wording is based on the 
Standard Library's istream_iterator wording.</span></i></p>
</blockquote>
<p>The result of calling the <code>path()</code> member of the <code>directory_entry</code> object obtained by dereferencing a <code>directory_iterator</code> is a reference to a <code>path</code> object composed of the directory argument from which the iterator was 
constructed with filename of the directory entry appended as if by <code>operator/=</code>. </p>
<p>Directory iteration shall not yield directory entries for the current (<i>dot</i>) 
and parent (<i>dot-dot</i>) directories.</p>
<p>The order of directory entries obtained by dereferencing successive 
increments of a <code>directory_iterator</code> is unspecified.</p>
<blockquote>
<p>[<i>Note:</i> Programs performing directory iteration may wish to test if the 
path obtained by dereferencing a directory iterator actually exists. It could be 
a
symbolic link to a non-existent file. Programs recursively 
walking directory trees for purposes of removing and renaming entries may wish 
to avoid following symbolic links.</p>
<p>If a file  is removed from or added to a directory after the 
construction of a <code>directory_iterator</code> for the directory, it is 
unspecified whether or not subsequently incrementing the iterator will ever 
result in an iterator referencing the removed or added directory entry. See
ISO/IEC 9945 <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/readdir_r.html">readdir_r()</a></code>. <i>--end note</i>]</p>
</blockquote>
<h3>1.13.1  <a name="directory_iterator-members"><code>directory_iterator</code> members</a> 
[directory_iterator.members]</h3>

<p><code><a name="directory_iterator-default-ctor">directory_iterator</a>() 
noexcept;</code></p>

<blockquote>

<p><i>Effects:</i> Constructs the end iterator.</p>

</blockquote>

<pre><code>explicit <a name="directory_iterator-ctor-path">directory_iterator</a>(</code>const path&amp; p<code>);
directory_iterator(</code>const path&amp; p, error_code&amp; ec<code>) noexcept;</code></pre>
<blockquote>

<p><i>Effects:</i> For the directory that <code>p</code> resolves to, constructs an 
iterator for the first element in a sequence of <code>directory_entry</code> 
elements representing the files in the directory, if any; otherwise the end iterator.</p>

<p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>

<p>[<i>Note:</i> To iterate over the current directory, use <code>directory_iterator(&quot;.&quot;)</code> rather than <code>directory_iterator(&quot;&quot;)</code>. <i>-- end note</i>]</p>
</blockquote>
<pre>directory_iterator&amp; <a name="directory_iterator-increment">operator++</a>();
directory_iterator&amp; increment(error_code&amp; ec)<code> noexcept</code>;</pre>
<blockquote>

<p><i>Effects:</i> As specified by the C++ Standard, 24.1.1 Input iterators [input.iterators]</p>

<p><i>Returns:</i> <code>*this</code>.</p>

<p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>

</blockquote>
<h3>1.13.2  <a name="directory_iterator-non-member-functions"><code>directory_iterator</code> non-member functions</a> 
[directory_iterator.nonmembers]</h3>
<p>These functions enable use of <code>directory_iterator</code> with C++11 
range-based for statements.</p>
<pre>const directory_iterator&amp; begin(const directory_iterator&amp; iter) noexcept;</pre>
<blockquote>
  <p><i>Returns: </i><code>iter</code>.</p>
</blockquote>
<pre>directory_iterator end(const directory_iterator&amp;) noexcept;</pre>
<blockquote>
  <p><i>Returns: </i><code>directory_iterator()</code>.</p>
</blockquote>
<h2>1.14  <a name="Class-recursive_directory_iterator">Class <code>recursive_directory_iterator</code> 
[class.rec.dir.itr]</a></h2>
<p>An object of type <code>recursive_directory_iterator</code> provides an iterator for 
a sequence of <code>directory_entry</code> elements representing the files in a 
directory and its sub-directories.</p>
<pre>namespace std { namespace tbd { namespace filesystem {

      class recursive_directory_iterator :
        public iterator&lt;input_iterator_tag, directory_entry&gt;
      {
      public:

        // constructors and destructor
        recursive_directory_iterator() noexcept;
        recursive_directory_iterator(const recursive_directory_iterator&amp;) = default;
        explicit recursive_directory_iterator(const path&amp; p,
          <a href="#symlink_option">directory_options</a> options = directory_options::none);
        recursive_directory_iterator(const path&amp; p,
          <a href="#symlink_option">directory_options</a> options, error_code&amp; ec) noexcept;
        recursive_directory_iterator(const path&amp; p, error_code&amp; ec) noexcept;
        recursive_directory_iterator(directory_iterator&amp;&amp;) = default;
       ~recursive_directory_iterator() = default;

        // observers
        directory_options  options() const;
        int                depth() const;
        bool               recursion<code>_pending</code>() const;

        // modifiers
        recursive_directory_iterator&amp; operator=(const directory_iterator&amp;) = default;
        recursive_directory_iterator&amp; operator=(directory_iterator&amp;&amp;) = default;

        recursive_directory_iterator&amp; operator++();
        recursive_directory_iterator&amp; increment(error_code&amp; ec);

        void pop();
        void disable_recursion_pending();

        // ... other members as required for Input iterators [input.iterators]
      };

} } }  // namespaces std::tbd::filesystem</pre>

<p>The behavior of a <code>recursive_directory_iterator</code> is the same 
as a <code>directory_iterator</code> unless otherwise specified.</p>
<h3>1.14.1  <code>recursive_<a name="directory_iterator-members">directory_iterator</a></code> members 
[<a name="rec.dir.itr.members">rec.dir.itr.members</a>]</h3>

<pre>recursive_directory_iterator() noexcept;</pre>
<blockquote>

<p><i>Effects:</i> Constructs the end iterator.</p>

</blockquote>

<pre>explicit recursive_directory_iterator(const path&amp; p,
  <a href="#symlink_option">directory_options</a> options = directory_options::none);
recursive_directory_iterator(const path&amp; p, <a href="#symlink_option">directory_options</a> options, error_code&amp; ec);
recursive_<code>directory_iterator(</code>const path&amp; p, error_code&amp; ec<code>);</code></pre>
<blockquote>

<p><i>Effects:</i>&nbsp; Constructs a iterator representing the first 
entry in the directory <code>p</code> resolves to, if any; otherwise, the end iterator.</p>

<p><i>Postcondition: </i><code>options() == options</code> for the signatures with a <code>
directory_options</code> argument, otherwise <code>options() == 
directory_options::none</code>.</p>

<p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>

<p>[<i>Note:</i> To iterate over the current directory, use <code>recursive_directory_iterator(&quot;.&quot;)</code> rather than <code>recursive_directory_iterator(&quot;&quot;)</code>. <i>-- end note</i>]</p>

<p>[<i>Note:</i> By default, <code>recursive_directory_iterator</code> does not 
follow directory symlinks. To follow directory symlinks, specify <code>options</code> as <code>
directory_options::follow_directory_symlink</code> <i>-- end note</i>]</p>
</blockquote>
<pre>directory_options options() const;</pre>
<blockquote>
  <p><i>Requires:</i> <code>*this != recursive_directory_iterator()</code>.</p>
<p><i>Returns:</i> The value of the constructor <code>options</code> argument, 
if present, otherwise <code>directory_options::none</code>.</p>
<p><i>Throws:</i> Nothing.</p>
</blockquote>
<pre>int depth() const;</pre>
<blockquote>
  <p><i>Requires:</i> <code>*this != recursive_directory_iterator()</code>.</p>
  <p><i>Returns:</i> The current depth of the directory tree being traversed. [<i>Note:</i> 
  The initial directory is depth 0, its immediate subdirectories are depth 1, 
  and so forth. <i>-- end note</i>]</p>
<p><i>Throws:</i> Nothing.</p>
</blockquote>
<pre>bool <code>recursion_pending</code>() const;</pre>
<blockquote>
  <p><i>Requires:</i> <code>*this != recursive_directory_iterator()</code>.</p>
  <p><i>Returns:</i> <code>true</code> iff <code>disable_recursion_pending()</code> 
  has not been called subsequent to the prior construction or increment 
  operation.</p>
  <p><i>Throws:</i> Nothing.</p>
</blockquote>
<pre><code>recursive_directory_iterator</code>&amp; <a name="recursive_directory_iterator-increment">operator++</a>();
recursive_directory_iterator&amp; increment(error_code&amp; ec);</pre>
<blockquote>

  <p><i>Requires:</i> <code>*this != recursive_directory_iterator()</code>.</p>

<p><i>Effects:</i> As specified by the C++ Standard, 24.1.1 Input iterators [input.iterators], 
except that:</p>

<ul>
  <li>

<p>If there are no more  entries at this depth, then if <code>depth()!= 0</code> 
iteration over the parent directory resumes; otherwise <code>*this = recursive_directory_iterator()</code>.</p>

  </li>
  <li>

<p>Otherwise if <code>recursion_pending() &amp;&amp; is_directory(this-&gt;status()) 
&amp;&amp; (!is_symlink(this-&gt;symlink_status()) || (options() &amp; 
directory_options::follow_directory_symlink) != 0)</code> then&nbsp;directory <code>(*this)-&gt;path()</code> is recursively iterated into.</p>

  </li>
</ul>

<p><i>Returns:</i> <code>*this</code>.</p>

<p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>

</blockquote>
<pre>void pop();</pre>
<blockquote>
  <p><i>Requires:</i> <code>*this != recursive_directory_iterator()</code>.</p>
  <p><i>Effects:</i> If <code>depth() == 0</code>, set <code>*this</code> to <code>recursive_directory_iterator()</code>. 
  Otherwise, cease iteration of the directory currently being 
  iterated over, and continue iteration over the parent directory.</p>
</blockquote>
<pre>void disable_recursion_pending();</pre>
<blockquote>
  <p><i>Requires:</i> <code>*this != recursive_directory_iterator()</code>.</p>
<p><i>Postcondition:</i> <code>recursion_pending() == false</code>.</p>
  <p>[<i>Note:</i> <code>disable_recursion_pending</code><code>()</code> is used to prevent 
  unwanted recursion into a directory. <i>--end note</i>]</p>
</blockquote>
<h3>1.14.2  <code>recursive_directory_iterator</code> non-member functions 
[<a name="rec.dir.itr.nonmembers">rec.dir.itr.nonmembers</a>]</h3>
<p>These functions enable use of <code>recursive_directory_iterator</code> 
with C++11 range-based for statements.</p>
<pre>const recursive_directory_iterator&amp; begin(const recursive_directory_iterator&amp; iter) noexcept;</pre>
<blockquote>
  <p><i>Returns: </i><code>iter</code>.</p>
</blockquote>
<pre>recursive_directory_iterator end(const recursive_directory_iterator&amp;) noexcept;</pre>
<blockquote>
  <p><i>Returns: </i><code>recursive_directory_iterator()</code>.</p>
</blockquote>
<h2>1.15  <a name="Operational-functions">Operational functions</a> [fs.op.funcs]</h2>
<p>Operational functions query or modify files, including directories, in external 
storage.</p>
<p>[<i>Note: </i>Because hardware failures, network failures, <a href="#file-system-race">file system races</a>, and many 
other kinds of errors occur frequently in file system operations, users should be aware 
that any filesystem operational function, no matter how apparently innocuous, may encounter 
an error.&nbsp;See <a href="#Error-reporting">Error reporting</a>. <i>-- end note</i>]</p>
<pre>path <a name="absolute">absolute</a>(const path&amp; p, const path&amp; base=current_path());</pre>
  <blockquote>
  <p><i>Returns:</i> An <a href="#Absolute-path">absolute path</a> composed according to the 
  following table</p>
  <table border="1" cellpadding="5" cellspacing="0" bordercolor="#111111" style="border-collapse: collapse">
    <tr>
      <td align="center">&nbsp;</td>
      <td align="center"><b><code>p.has_root_directory()</code></b></td>
      <td align="center"><b><code>!p.has_root_directory()</code></b></td>
    </tr>
    <tr>
      <td align="center"><b><code>p.has_root_name()</code></b></td>
      <td align="center"><code>return p</code></td>
      <td align="center"><code>return p.root_name() / absolute(base).root_directory()<br>
      / absolute(base).relative_path() / p.relative_path()</code></td>
    </tr>
    <tr>
      <td align="center"><b><code>!p.has_root_name()</code></b></td>
      <td align="center"><code>return absolute(base).root_name()<br>
      / p</code></td>
      <td align="center"><code>return absolute(base) / p</code></td>
    </tr>
  </table>
  <p>[<i>Note:</i> For the returned path, <code>rp,</code> <code>rp.is_absolute()</code> is true. <i>-- end note</i>]</p>
  <p><i>Throws:</i> If <code>base.is_absolute()</code> is true, throws only if 
  memory allocation fails.</p>
</blockquote>
<pre>path <a name="canonical">canonical</a>(const path&amp; p, const path&amp; base = current_path());
path canonical(const path&amp; p, error_code&amp; ec);
path canonical(const path&amp; p, const path&amp; base, error_code&amp; ec);</pre>
<blockquote>
<p><i>Overview:</i> Converts <code>p</code>, which must exist, to an absolute 
path that has no symbolic link, <code>&quot;.&quot;</code>, 
or <code>&quot;..&quot;</code> elements. </p>
<p><i>Returns:</i> A path that refers to 
the same file system object as <code>absolute(p,base)</code>. For the overload 
without a <code>base</code> argument, <code>base</code> is <code>current_path()</code>. 
Signatures with argument <code>ec</code> return <code>path()</code> if an error occurs.</p>
  <p><i>Throws:</i>&nbsp; As specified in <a href="#Error-reporting">Error reporting</a>.</p>
  
  <p><i>Remarks:</i> <code>!exists(p)</code> is an error.</p>
  
  <p>[<i>Note:</i> Canonical pathnames allow security checking of a path (e.g. 
  does this path live in /home/goodguy or /home/badguy?)&nbsp; <i>-- end note</i>]</p>
  
</blockquote>
<pre>void <a name="copy">copy</a>(const path&amp; from, const path&amp; to);
void copy(const path&amp; from, const path&amp; to, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects: </i><code>copy(from, to, copy_options::none<i>[, ec]</i>)</code>.</p>
  
</blockquote>

<pre>void <a name="copy">copy</a>(const path&amp; from, const path&amp; to, <a href="#copy_option">copy_options</a> options);
void copy(const path&amp; from, const path&amp; to, <a href="#copy_option">copy_options</a> options, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Precondition:</i> At most one constant from each option group ([<a href="#enum.copy_options">enum.copy_options</a>]) 
  is present in <code>options</code>.</p>
  <p><i>Effects:</i></p>
  
  <blockquote>
  <p>Before the first use of <code>f</code> and <code>t</code>:</p>
  
    <ul>
      <li>If <code>(options &amp; copy_options::make_symlinks) || (options &amp; 
      copy_options::skip_symlinks)</code>, then <code>auto f = 
      symlink_status(from)</code> and if needed <code>auto t = symlink_status(to)</code>.</li>
      <li>Otherwise, <code>auto f = status(from)</code> and if needed <code>auto 
      t = status(to)</code>.</li>
    </ul>
  <p>Report an error as specified in <a href="#Error-reporting">Error reporting</a> 
  if:</p>
  
    <ul>
      <li><code>!exists(f)</code>.</li>
      <li>
  <p><code>equivalent(f, t)</code>.</p>
  
      </li>
      <li>
  <p><code>is_other(f) || is_other(t)</code>.</p>
  
      </li>
      <li>
  <p><code>is_directory(f) &amp;&amp; is_regular_file(t)</code>.</p>
  
      </li>
    </ul>
  <p>If <code>is_symlink_file(f)</code>, then:</p>
  
    <ul>
      <li>If <code>options &amp; copy_options::skip_symlinks</code>, then return.</li>
      <li>Otherwise if <code>!exists(t)</code>, then <code>copy_symlink(from, 
      to, options)</code>.</li>
      <li>Otherwise report an error as specified in <a href="#Error-reporting">Error reporting</a>.</li>
    </ul>
  <p>Otherwise if <code>is_regular_file(f)</code>, then:</p>
  
    <ul>
      <li>If <code>options &amp; copy_options::structure_only</code>, then return.</li>
      <li>Otherwise if <code>options &amp; copy_options::make_symlinks</code>, then 
      create a symbolic link to the source file.</li>
      <li>Otherwise if <code>options &amp; copy_options::make_hard_links</code>, 
      then create a hard link to the source file.</li>
      <li>Otherwise:<ul>
        <li>If <code>is_directory(t)</code>, then <code>copy_file(from, to/from.filename(), 
        options)</code>.</li>
        <li>Otherwise, <code>copy_file(from, to, options)</code>.</li>
      </ul>
      </li>
    </ul>
  </blockquote>
</blockquote>
<blockquote>
  <blockquote>
  <p>Otherwise if <code>is_directory(f) &amp;&amp; ((options &amp; 
  copy_options::recursive) || !(options &amp; copy_options::<i>unspecified</i>))</code> 
  then:</p>
  
    <ul>
      <li>If&nbsp; <code>!exists(t)</code>, then <code>create_directory(to, 
      from)</code>.</li>
      <li>Then, iterate over the files in <code>from</code>, as if by <code>for 
      (directory_entry&amp; x : directory_iterator(from))</code>, and for each 
      iteration <code>copy(x.path(), to/x.path().filename(), options | 
      copy_options::<i>unspecified</i>)</code>.</li>
    </ul>
  <p>Otherwise no effects.</p>
  
  </blockquote>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
  
  <p><i>Remarks: </i>For the signature with argument <code>ec</code>, any 
  Filesystem library functions called by the implementation shall have an <code>
  error_code</code> argument if applicable. </p>
  
  <p>[<i>Example:</i> Given this directory structure:</p>
  
  <pre>/dir1
  file1
  file2
  dir2
    file3</pre>
  <p>Calling <code>copy(&quot;/dir1&quot;, &quot;/dir3&quot;)</code> would result in: </p>
  <pre>/dir1
  file1
  file2
  dir2
    file3
/dir3
  file1
  file2
</pre>
  <p>Alternatively, calling <code>copy(&quot;/dir1&quot;, &quot;/dir3&quot;, 
  copy_options::recursive)</code> would result in: </p>
  
  <pre>/dir1
  file1
  file2
  dir2
    file3  
/dir3
  file1
  file2
  dir2
    file3</pre>

<p><i>-- end example</i>]</p>
  
</blockquote>

<pre>void copy_file(const path&amp; from, const path&amp; to);
void copy_file(const path&amp; from, const path&amp; to, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects: </i><code>copy_file(from, to, copy_options::none</code><i>[</i><code>, ec</code><i>]</i><code>)</code>.</p>
  
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
  
</blockquote>
<pre>void <a name="copy_file">copy_file</a>(const path&amp; from, const path&amp; to, <a href="#copy_option">copy_options</a> options);
void <a name="copy_file2">copy_file</a>(const path&amp; from, const path&amp; to, <a href="#copy_option">copy_options</a> options,
               error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Precondition:</i> At most one constant from each <code>copy_options</code> 
  option group ([<a href="#enum.copy_options">enum.copy_options</a>]) is present 
  in <code>options</code>.</p>
  <p><i>Effects:</i></p>
  <blockquote>
  <p>&nbsp;If <code>exists(to)</code>is true:</p>
    <ul>
      <li>If <code>options &amp; copy_options::skip</code> return <code>false</code>.</li>
      <li>otherwise if <code>options &amp; copy_options::update</code>:<ul>
        <li>&nbsp;if <code>last_write_time(from) &lt;= last_write_time(to)</code>return
        <code>false</code>.</li>
        <li>otherwise proceed with copying.</li>
      </ul>
      </li>
      <li>otherwise if <code>!(options &amp; copy_options::overwrite)</code>report a 
      file already exists error as specified in <a href="#Error-reporting">Error reporting</a>.</li>
    </ul>
  <p>Copy the contents and attributes of the file <code>from</code> resolves to  the file <code>to</code> resolves to.</p>
  </blockquote>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
</blockquote>
<pre>void <a name="copy_symlink">copy_symlink</a>(const path&amp; existing_symlink, const path&amp; new_symlink);
void copy_symlink(const path&amp; existing_symlink, const path&amp; new_symlink,
                  error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects: </i><code>create_symlink(read_symlink(existing_symlink</code><i>[</i><code>, ec</code><i>]</i><code>), new_symlink</code><i>[</i><code>, ec</code><i>]</i><code>)</code>.</p>
  
  <p><blink><span style="background-color: #FFFF99">Wrong! If the </span>
  <span style="background-color: #FFFF99">symlink</span><span style="background-color: #FFFF99"> 
  is a directory </span><span style="background-color: #FFFF99">symlink</span><span style="background-color: #FFFF99">, 
  need to call create_directory_symlink()</span></blink></p>
  
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
  
</blockquote>
<pre>bool <a name="create_directories">create_directories</a>(const path&amp; p);
bool <a name="create_directories2">create_directories</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> Establishes the postcondition by calling <code>
  create_directory()</code> for any element of <code>p</code> that does not 
  exist.</p>
  <p><i>Postcondition:</i> <code>is_directory(p)</code></p>
  <p><i>Returns:</i> <code>true</code> if a new directory was created, otherwise <code>
  false</code>. The signature with argument <code>ec</code> returns false if an 
  error occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
  <p><i>Complexity:</i> <i>O(n+1)</i> where <i>n</i> is the number of elements 
  of <code>p</code> that do not exist.</p>
</blockquote>
<pre>bool <a name="create_directory">create_directory</a>(const path&amp; p);
bool create_directory(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> Establishes the postcondition by attempting to create the 
  directory <code>p</code> resolves to, as if by ISO/IEC 9945 <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/mkdir.html">
  mkdir()</a></code> with a second argument of S_IRWXU|S_IRWXG|S_IRWXO. Creation 
  failure because <code>p</code> resolves to an existing directory shall not be 
  treated as an error. </p>
  <p><i>Postcondition:</i> <code>is_directory(p)</code></p>
  <p><i>Returns:</i> <code>true</code> if a new directory was created, otherwise <code>false</code>. 
  The signature with argument <code>ec</code> returns false if an error occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
</blockquote>

<pre>void <a name="create_directory2">create_directory</a>(const path&amp; p, const path&amp; attributes);
void create_directory(const path&amp; p, const path&amp; attributes, error_code&amp; ec) noexcept;</pre>
<blockquote>

  <p><i>Effects: </i>Creates directory <code>p</code>, with 
  attributes copied from directory <code>attributes</code>. The set of attributes 
  copied is operating system dependent.</p>
  
<blockquote>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse"
   bordercolor="#111111" width="90%" bgcolor="#E8FFE8">
    <tr>
      <td width="100%">
      <p>[<i>Note:</i> For ISO 9945/POSIX based operating systems the 
      attributes are those copied by native API <code>stat(attributes.c_str(), &amp;attributes_stat)</code> 
      followed by <code>mkdir(p.c_str(),attributes_stat.st_mode)</code>.&nbsp; For 
      Windows based operating systems the attributes are those copied by native 
      API <code>CreateDirectoryExW(attributes.c_str(), p.c_str(), 0)</code>.&nbsp; <i>
      --end note</i>]</td>
    </tr>
  </table>
</blockquote>
  
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>

</blockquote>

<pre>void <a name="create_directory_symlink">create_directory_symlink</a>(const path&amp; to, const path&amp; new_symlink);
void create_directory_symlink(const path&amp; to, const path&amp; new_symlink,
                              error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> Establishes the postcondition, as if by ISO/IEC 9945 <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/symlink.html">symlink()</a></code>.</p>
  <p><i>
  Postcondition:</i> <code>new_symlink</code> resolves to a symbolic link file that 
  contains an unspecified representation of <code>to</code>.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
  <p>[<i>Note:</i> Some operating systems require symlink creation to 
  identify that the link is to a directory. Portable code should use <code>create_directory_symlink()</code> to create directory symlinks rather than <code>create_symlink()</code> <i>-- end note</i>]</p>
  <p>[<i>Note:</i> Some operating systems do not support symbolic links at all or support 
  them only for regular files. 
  Some file systems do not 
  support 
  symbolic links regardless of the operating system - the FAT file system used on 
  memory cards and flash drives, for example. <i>-- end note</i>]</p>
  </blockquote>
<pre>void <a name="create_hard_link">create_hard_link</a>(const path&amp; to, const path&amp; new_hard_link);
void <a name="create_hard_link2">create_hard_link</a>(const path&amp; to, const path&amp; new_hard_link,
                                      error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> Establishes the postcondition, as if by ISO/IEC 9945 <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/link.html">link()</a></code>.</p>
  <p><i>Postcondition:</i></p>
  <ul>
    <li>&nbsp;<code>exists(to) &amp;&amp; 
    exists(</code><code>new_hard_link</code><code>) &amp;&amp; equivalent(to, 
     
    </code><code>new_hard_link</code><code>)</code></li>
    <li>The contents of the file or directory
    <code>to</code> resolves to are unchanged.</li>
  </ul>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
  <p>[<i>Note:</i> Some operating systems do not support hard links at all or support 
  them only for regular files. Some file systems do not support hard 
  links regardless of the operating system - the FAT file system used on memory 
  cards and flash drives, for example. Some file systems limit the number of 
  links per file. <i>-- end note</i>]</p>
  </blockquote>
<pre>void <a name="create_symlink">create_symlink</a>(const path&amp; to, const path&amp; new_symlink);
void <a name="create_symlink2">create_symlink</a>(const path&amp; to, const path&amp; new_symlink,
                    error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> Establishes the postcondition, as if by ISO/IEC 9945 <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/symlink.html">symlink()</a></code>.</p>
  <p><i>
  Postcondition:</i> <code>new_symlink</code> resolves to a symbolic link file that 
  contains an unspecified representation of <code>to</code>.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
  <p>[<i>Note:</i> Some operating systems do not support symbolic links at all or support 
  them only for regular files. 
  Some file systems do not 
  support 
  symbolic links regardless of the operating system - the FAT system used on 
  memory cards and flash drives, for example. <i>-- end note</i>]</p>
  </blockquote>
<pre>path <a name="current_path">current_path</a>();
path <a name="current_path2">current_path</a>(error_code&amp; ec);</pre>
<blockquote>
  <p><i>Returns:</i> The absolute path of the current working directory, 
  obtained as if by ISO/IEC  
  9945 <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/getcwd.html">getcwd()</a></code>. 
  The signature with argument <code>ec</code> returns <code>path()</code> if an 
  error occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
  <p><i>Remarks: </i>The current working directory is the directory, associated 
  with the process, that is used as the starting location in pathname resolution 
  for relative paths.</p>
  <p>[<i>Note: </i>The <code>current_path()</code> name was chosen to emphasize that the return is a 
  path, not just a single directory name.</p>
  <p>The current path as returned by many operating systems is a dangerous 
  global variable. It may be changed unexpectedly by a third-party or system 
  library functions, or by another thread.&nbsp; <i>-- end note</i>]</p>
</blockquote>
<pre>void current_path(const path&amp; p);
void current_path(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> Establishes the postcondition, as if by ISO/IEC 9945 <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/chdir.html">chdir()</a></code>.</p>
<p><i>Postcondition:</i> <code>equivalent(p, current_path())</code>.</p>
<p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
  <p>[<i>Note: </i>The current path for many operating systems is a dangerous 
  global state. It may be changed unexpectedly by a third-party or system 
  library functions, or by another thread.&nbsp; <i>-- end note</i>]</p>
</blockquote>
<pre>bool <a name="exists">exists</a>(file_status s) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>status_known(s) &amp;&amp; s.type() != 
  file_type::not_found</code></p>
</blockquote>
<pre>bool <a name="exists2">exists</a>(const path&amp; p);
bool <a name="exists3">exists</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>exists(status(p))</code> or <code>exists(status(p, ec))</code>, 
  respectively. The signature with argument <code>ec</code> returns <code>false</code> 
  if an error occurs.</p>
<p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
</blockquote>
<pre><code>bool <a name="equivalent">equivalent</a>(const path&amp; p1, const path&amp; p2);
bool <a name="equivalent2">equivalent</a>(const path&amp; p1, const path&amp; p2, error_code&amp; ec)</code> noexcept<code>;</code></pre>
<blockquote>
  <p><i>Effects:</i> Determines <code>file_status s1</code> and <code>s2</code>, as if by <code>status(p1)</code> and&nbsp; <code>status(p2)</code>, 
  respectively.</p>
  <p><i>Returns:</i> <code>true</code>, if <code>sf1 == 
  sf2</code> and <code>p1</code> and <code>p2</code> resolve to the same file 
  system entity, else <code>false</code>. The signature with argument <code>ec</code> 
  returns <code>false</code> if an error occurs.</p>
  <blockquote>
  <p>Two paths are considered to resolve to the same 
  file system entity if two candidate entities reside on the same device at the 
  same location. This is determined as if by the values of the ISO/IEC 9945 <code><a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">stat</a></code> structure<code>,</code> obtained as if by <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/stat.html">stat()</a></code> for the two paths, having equal <code>st_dev</code> values 
  and equal <code>st_ino</code> values.</p>
  <p><i><span style="background-color: #E0E0E0">[Note: ISO/IEC 9945 requires that &quot;st_dev must be unique within a Local Area Network&quot;. Conservative
  ISO/IEC 9945 implementations may also wish to check for equal <code>st_size</code> and <code>st_mtime</code> values. Windows implementations may use <code>GetFileInformationByHandle()</code> as a surrogate for <code>stat()</code>, 
  and consider &quot;same&quot; to be equal values for <code>dwVolumeSerialNumber</code>, <code>nFileIndexHigh</code>, <code>nFileIndexLow</code>, <code>nFileSizeHigh</code>, <code>nFileSizeLow</code>, <code>ftLastWriteTime.dwLowDateTime</code>, and <code>ftLastWriteTime.dwHighDateTime</code>. -- end note]</span></i></p>
  </blockquote>
  <p><i>Throws:</i> <code>filesystem_error</code> if <code>(!exists(s1) &amp;&amp; !exists(s2)) || (is_other(s1) &amp;&amp; is_other(s2))</code>, 
  otherwise as specified in <a href="#Error-reporting">Error reporting</a>.</p>
</blockquote>
<pre>uintmax_t <a name="file_size">file_size</a>(const path&amp; p);
uintmax_t <a name="file_size2">file_size</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> If <code>exists(p) &amp;&amp; is_regular_file(p)</code>, the size 
  in bytes 
  of the file <code>p</code> resolves to, determined as if by the value of 
  the ISO/IEC 9945 <code><a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">stat</a></code> structure member <code>st_size</code> obtained as if by
  ISO/IEC 9945 <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/stat.html">stat()</a></code>. 
  Otherwise, <code>static_cast&lt;uintmax_t&gt;(-1)</code>. The signature with 
  argument <code>ec</code> 
  returns <code>static_cast&lt;uintmax_t&gt;(-1)</code> if an error occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
</blockquote>
<pre>uintmax_t <a name="hard_link_count">hard_link_count</a>(const path&amp; p);
uintmax_t hard_link_count(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>

  <p><i>Returns:</i> The number of hard links for <code>p</code>. The signature 
  with argument <code>ec</code> returns <code>static_cast&lt;uintmax_t&gt;(-1)</code> 
  if an error occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>

</blockquote>

<pre>bool <code><a name="is_block_file">is_block_file</a></code>(file_status s) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>s.type() == file_type::block</code></p>
</blockquote>
<pre><code>bool <a name="is_directory2">is_block_file</a>(const path&amp; p);
bool <a name="is_directory3">is_</a><a name="is_directory2">block_file</a>(const path&amp; p, error_code&amp; ec) noexcept;</code></pre>
<blockquote>
  <p><i>Returns:</i> <code>is_block_file(status(p))</code> or <code>
  is_block_file(status(p, ec))</code>, respectively. The signature with argument <code>
  ec</code> returns <code>false</code> if an error occurs.</p>
<p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
</blockquote>

<pre>bool <code><a name="is_character_file">is_character_file</a></code>(file_status s) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>s.type() == file_type::character</code></p>
</blockquote>
<pre><code>bool <a name="is_directory">is_character_file</a>(const path&amp; p);
bool <a name="is_directory">is_character_file</a>(const path&amp; p, error_code&amp; ec) noexcept;</code></pre>
<blockquote>
  <p><i>Returns:</i> <code><a name="is_directory">is_character_file</a>(status(p))</code> 
  or <code><a name="is_directory">is_character_file</a>(status(p, ec))</code>, 
  respectively. The signature with argument <code>ec</code> returns <code>false</code> 
  if an error occurs.</p>
<p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
</blockquote>

<pre>bool <code><a name="is_directory">is_directory</a></code>(file_status s) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>s.type() == file_type::directory</code></p>
</blockquote>
<pre><code>bool <a name="is_directory2">is_directory</a>(const path&amp; p);
bool <a name="is_directory3">is_directory</a>(const path&amp; p, error_code&amp; ec) noexcept;</code></pre>
<blockquote>
  <p><i>Returns:</i> <code>is_directory(status(p))</code> or <code>
  is_directory(status(p, ec))</code>, respectively. The signature with argument <code>
  ec</code> returns <code>false</code> if an error occurs.</p>
<p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
</blockquote>
<pre><code>bool <a name="is_empty">is_empty</a>(const path&amp; p);
bool <a name="is_empty2">is_empty</a></a>(const path&amp; p, error_code&amp; ec)</code> noexcept<code>;</code></pre>
<blockquote>
  <p><i>Effects:</i> Determines <code>file_status s</code>, as if by <code>status(p, ec)</code>.</p>
  <p><i>Returns:</i> <code>is_directory(s)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ? directory_iterator(p) == directory_iterator()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : file_size(p) == 0;</code></p>
  <blockquote>
  <p>The signature with argument <code>ec</code> returns <code>false</code> if 
  an error occurs.</p>
  </blockquote>

<p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
</blockquote>

<pre>bool <code><a name="is_fifo">is_fifo</a></code>(file_status s) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>s.type() == file_type::fifo</code></p>
</blockquote>
<pre><code>bool is_fifo(const path&amp; p);
bool is_fifo(const path&amp; p, error_code&amp; ec) noexcept;</code></pre>
<blockquote>
  <p><i>Returns:</i> <code>is_fifo(status(p))</code> or <code>is_fifo(status(p, 
  ec))</code>, respectively. The signature with argument <code>ec</code> returns <code>
  false</code> if an error occurs.</p>
<p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
</blockquote>
<pre>bool <a name="is_other">is_other</a>(file_status s) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>return exists(s) &amp;&amp; !is_regular_file(s) &amp;&amp; !is_directory(s) &amp;&amp; !is_symlink(s)</code></p>
</blockquote>
<pre><code>bool <a name="is_other2">is_other</a>(const path&amp; p);
bool <a name="is_other3">is_other</a>(const path&amp; p, error_code&amp; ec) noexcept;</code></pre>
<blockquote>
  <p><i>Returns:</i> <code>is_other(status(p))</code> or <code>is_other(status(p, ec))</code>, 
  respectively. The signature with argument <code>ec</code> returns <code>false</code> 
  if an error occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
</blockquote>
<pre>bool <code><a name="is_regular_file">is_regular_file</a></code>(file_status s) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>s.type() == file_type::regular</code>.</p>
</blockquote>
<pre><code>bool <a name="is_regular_file2">is_regular_file</a>(const path&amp; p);</code></pre>
<blockquote>
  <p><i>Returns:</i> <code>is_regular_file(status(p))</code>.</p>
  <p><i>Throws:</i> <code>filesystem_error</code> if <code>status(p)</code> would throw <code>filesystem_error.</code></p>
  </blockquote>
<pre><code>bool <a name="is_regular_file3">is_regular_file</a>(const path&amp; p, error_code&amp; ec) noexcept;</code></pre>
<blockquote>
  <p><i>Effects:</i> Sets <code>ec</code> as if by <code>status(p, ec)</code>. [<i>Note:</i> <code>
  file_type::none</code>, <code>file_type::not_found</code> and <code>
  file_type::unknown</code> cases set <code>ec</code> to error values. To distinguish between cases, call the <code>status</code> function directly. <i>-- end 
  note</i>] </p>
  <p><i>Returns:</i> <code>is_regular_file(status(p, ec))</code>. Returns <code>
  false</code> if an error occurs.</p>
</blockquote>

<pre>bool <code><a name="is_socket">is_socket</a></code>(file_status s) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>s.type() == file_type::socket</code></p>
</blockquote>
<pre><code>bool is_socket(const path&amp; p);
bool is_socket(const path&amp; p, error_code&amp; ec) noexcept;</code></pre>
<blockquote>
  <p><i>Returns:</i> <code>is_socket(status(p))</code> or <code>
  is_socket(status(p, ec))</code>, respectively. The signature with argument <code>
  ec</code> returns <code>false</code> if an error occurs.</p>
<p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
</blockquote>
<pre>bool <a name="is_symlink">is_symlink</a>(file_status s) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>s.type() == file_type::symlink</code></p>
</blockquote>
<pre><code>bool <a name="is_symlink2">is_symlink</a>(const path&amp; p);
bool <a name="is_symlink3">is_symlink</a>(const path&amp; p, error_code&amp; ec) noexcept;</code></pre>
<blockquote>
  <p><i>Returns:</i> <code>is_symlink(symlink_status(p))</code> or <code>is_symlink(symlink_status(p, ec))</code>, 
  respectively. The signature with argument <code>ec</code> returns <code>false</code> 
  if an error occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
</blockquote>
<pre>file_time_type <a name="last_write_time">last_write_time</a>(const path&amp; p);
file_time_type <a name="last_write_time2">last_write_time</a>(const path&amp; p<code>, error_code&amp; ec</code>) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> The time of last data modification of <code>p</code>, determined as if by the 
  value of the ISO/IEC 9945 <code><a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">stat</a></code> structure member <code>st_mtime</code>&nbsp; obtained 
  as if by ISO/IEC 9945 <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/stat.html">stat()</a></code>. 
  The signature with argument <code>ec</code> returns <code>static_cast&lt;file_time_type&gt;(-1)</code> 
  if an error occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
</blockquote>
<pre>void <a name="last_write_time3">last_write_time</a>(const path&amp; p, file_time_type new_time);
void <a name="last_write_time4">last_write_time</a>(const path&amp; p, file_time_type new_time<code>,
                     error_code&amp; ec</code>) noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> Sets the time of last data modification of the file 
  resolved to by <code>p</code> to <code>new_time</code>, as if by ISO/IEC 
  9945 <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/stat.html">stat()</a></code> followed by
  ISO/IEC 9945 <a href="http://www.opengroup.org/onlinepubs/000095399/functions/utime.html"><code>utime()</code></a>.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
  <p>[<i>Note:</i> A postcondition of <code>last_write_time(p) == new_time</code> is not specified since it might not hold for file systems 
  with coarse time granularity. <i>-- end note</i>]</p>
</blockquote>
<pre>void <a name="permissions">permissions</a>(const path&amp; p, <a href="#symlink_perms">perms</a> prms);
void permissions(const path&amp; p, <a href="#symlink_perms">perms</a> prms, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p>
  <i>Requires:</i> <code>!((prms &amp; add_perms) &amp;&amp; (prms &amp; remove_perms))</code>.</p>
  <p><i>Effects:</i> Applies the effective permissions bits from <code>prms</code> to the file <code>p</code> resolves to, as if by
  ISO/IEC 9945 <code><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/fchmodat.html">fchmodat()</a></code>. The effective permission bits are determined as 
  specified by the following table. </p>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
    <tr>
      <td><b>bits present in <code>prms</code></b></td>
      <td><b>Effective bits applied</b></td>
    </tr>
    <tr>
      <td>Neither <code>add_perms</code> nor <code>remove_perms</code></td>
      <td><code>prms &amp; perms_mask</code></td>
    </tr>
    <tr>
      <td><code>add_perms</code></td>
      <td>
      <p><code>status(p).permissions() | (prms &amp; <a href="#perms_mask">perms_mask</a>)</code> </td>
    </tr>
    <tr>
      <td><code>remove_perms</code></td>
      <td><code>status(p)</code><code>.permissions() &amp; ~(prms &amp; <a href="#perms_mask">perms_mask</a>) </code></td>
    </tr>
  </table>
  <p>[<i>Note:</i> Conceptually permissions are viewed as bits, but the actual 
  implementation may use some other mechanism. -- <i>end note</i>]</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
</blockquote>
<pre>path <a name="read_symlink">read_symlink</a>(const path&amp; p);
path read_symlink(const path&amp; p, error_code&amp; ec);</pre>
<blockquote>
  <p><i>Returns:</i>&nbsp; If <code>p</code> resolves to a symbolic 
  link, a <code>path</code> object containing the contents of that symbolic 
  link. Otherwise <code>path()</code>. The signature with argument <code>ec</code> 
  returns <code>path()</code> if an error occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>. [<i>Note:</i> It is an error if <code>p</code> does not 
  resolve to a symbolic link. <i>-- end note</i>]</p>
</blockquote>
<pre>bool <a name="remove">remove</a>(const path&amp; p);
bool <a name="remove2">remove</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects:</i>&nbsp; If <code>exists(symlink_status(p,ec))</code>, it is 
  removed 
  as if by ISO/IEC 9945 <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/remove.html">remove()</a></code>.</p>
  <blockquote>
  <p>[<i>Note:</i> A symbolic link is itself removed, rather than the file it 
  resolves to being removed. <i>-- end note</i>]</p>
  </blockquote>
  <p><i>Postcondition:</i> <code>!exists(symlink_status(p))</code>.</p>
  <p><i>Returns:</i>&nbsp; <code>false</code> if p did not exist in the first 
  place, otherwise <code>true</code>. The signature with argument <code>ec</code> 
  returns <code>false</code> if an error occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
</blockquote>
<pre>uintmax_t <a name="remove_all">remove_all</a>(const path&amp; p);
uintmax_t <a name="remove_all2">remove_all</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects:</i>&nbsp; Recursively deletes the contents of p if it exists, 
  then deletes file <code>p</code> itself, 
  as if by ISO/IEC 9945 <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/remove.html">remove()</a></code>.</p>
  <blockquote>
  <p>[<i>Note:</i> A symbolic link is itself removed, rather than the file it 
  resolves to being removed. <i>-- end note</i>]</p>
  </blockquote>
  <p><i>Postcondition:</i> <code>!exists(p)</code></p>
  <p><i>Returns:</i> The number of files removed. The signature with argument
  <code>ec</code> returns <code>static_cast&lt;uintmax_t&gt;(-1)</code> if an error 
  occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
</blockquote>
<pre>void <a name="rename">rename</a>(const path&amp; old_p, const path&amp; new_p);
void <a name="rename2">rename</a>(const path&amp; old_p, const path&amp; new_p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> Renames <code>old_p</code> to <code>new_p</code>, as if by
  ISO/IEC 9945 <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/rename.html">rename()</a></code>.</p>
  <blockquote>
  <p>[<i>Note:</i> If <code>old_p</code> and <code>new_p</code> resolve to the 
  same existing file, no action is taken. Otherwise, if <code>new_p</code> resolves to an 
  existing non-directory file, it is removed, while if <code>new_p</code> resolves to an 
  existing directory, it is removed if empty on ISO/IEC 9945 compliant operating 
  systems but is an error on some other operating systems. A symbolic link is itself renamed, rather than 
  the file it resolves to being renamed. <i>-- end note</i>]</p>
  </blockquote>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
</blockquote>
<pre>void <a name="resize_file">resize_file</a>(const path&amp; p, uintmax_t new_size);
void <a name="resize_file2">resize_file</a>(const path&amp; p, uintmax_t new_size, error_code&amp; ec) noexcept;</pre>
<blockquote>
<p><i>Postcondition:</i> <code>file_size() == new_size</code>.</p>
<p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
  <p><i>Remarks:</i> Achieves its postconditions as if by ISO/IEC 9945 <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/truncate.html">truncate()</a></code>.</p>
</blockquote>
<pre>space_info <a name="space">space</a>(const path&amp; p);
space_info <a name="space2">space</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> An object of type <code><a href="#space_info">space_info</a></code>. The value of the <code>space_info</code> object is determined as if by 
  using ISO/IEC 9945 <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/statvfs.html"
   style="text-decoration: none">statvfs()</a></code> to obtain a ISO/IEC 9945 struct
  <code><a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/statvfs.h.html" style="text-decoration: none">statvfs</a></code>,
   and then multiplying its <code>f_blocks</code>, <code>f_bfree</code>,
   and <code>f_bavail</code> members by its <code>f_frsize</code> member,
   and assigning the results to the <code>capacity</code>, <code>free</code>, 
  and <code>available</code> members respectively. Any members for which the 
  value cannot be determined shall be set to <code>static_cast&lt;uintmax_t&gt;(-1)</code>. 
  For the signature with argument <code>ec</code>, all members are set to <code>
  static_cast&lt;uintmax_t&gt;(-1)</code> if an error occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
</blockquote>
<pre><a href="#file_status">file_status</a> <a name="status">status</a>(const path&amp; p);</pre>
<blockquote>
  <p><i>Effects: </i>As if:</p>
  <blockquote>
    <pre>error_code ec;
file_status result = status(p, ec);
if (result == file_type::none)
  throw filesystem_error(<i>implementation-supplied-message</i>, p, ec);
return result;</pre>
  </blockquote>
  <p><i>Returns:</i> See above.</p>
  <p><i>Throws:</i> <code>filesystem_error</code>. 
[<i>Note:</i> <code>result</code> values of <code>
  file_status(file_type::not_found)</code> 
  and <code>file_status(file_type::unknown)</code> are not considered failures and do not 
  cause an exception to be 
thrown.<i> -- end note</i>] </p>
  </blockquote>
<pre><a href="#file_status">file_status</a> <a name="status2">status</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects: </i></p>
  <blockquote>
    <p>If possible, determines the attributes 
    of the file <code>p</code> resolves to, as if by ISO/IEC 9945 <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/stat.html">stat()</a></code>.</p>
      If, during attribute determination, the underlying file system API reports 
    an error, sets <code>ec</code> to indicate the specific error reported. 
    Otherwise, <code>ec.clear()</code>.<blockquote>
      <p>[<i>Note:</i> This allows users to inspect the specifics of underlying 
      API errors even when the value returned by <code>status()</code> is not <code>
      file_status(file_type::none)</code>.&nbsp; <i>--end note</i>]</p>
    </blockquote>
    </blockquote>
  <p><i>Returns:</i></p>
  <blockquote>
    <p>If <code>ec != error_code()</code>:</p>
    <ul>
      <li>If the specific error indicates that <code>p</code> cannot be resolved 
      because some element of the path does not exist, return <code>
      file_status(file_type::not_found)</code>.<span style="font-style: italic; background-color: #E0E0E0"> [</span><i><span style="background-color: #E0E0E0">Note: ISO/</span><span style="background-color: #E0E0E0">IEC</span><span style="background-color: #E0E0E0"> 9945 errors that 
      indicate this are </span><span style="background-color: #E0E0E0">ENOENT</span><span style="background-color: #E0E0E0"> or 
      </span><span style="background-color: #E0E0E0">ENOTDIR</span><span style="background-color: #E0E0E0">. Windows equivalents 
      include </span><span style="background-color: #E0E0E0">
      ERROR_FILE_NOT_FOUND</span><span style="background-color: #E0E0E0">, 
      </span><span style="background-color: #E0E0E0">ERROR_PATH_NOT_FOUND</span><span style="background-color: #E0E0E0">, 
      </span><span style="background-color: #E0E0E0">ERROR_INVALID_NAME</span><span style="background-color: #E0E0E0">, 
      </span><span style="background-color: #E0E0E0">ERROR_INVALID_PARAMETER</span><span style="background-color: #E0E0E0">, 
      </span><span style="background-color: #E0E0E0">ERROR_BAD_PATHNAME</span><span style="background-color: #E0E0E0">, and 
      </span><span style="background-color: #E0E0E0">ERROR_BAD_NETPATH</span><span style="background-color: #E0E0E0">. -- 
      end note</span></i><span style="font-style: italic; background-color: #E0E0E0">]</span><br>
&nbsp;</li>
      <li>Otherwise, if the specific error indicates that <code>p</code> can be resolved 
      but the attributes cannot be determined, return <code>
      file_status(file_type::unknown)</code>. 
      <span style="font-style: italic; background-color: #E0E0E0">[</span><i><span style="background-color: #E0E0E0">Note: For example, Windows 
      </span><span style="background-color: #E0E0E0">ERROR_SHARING_VIOLATION</span><span style="background-color: #E0E0E0"> errors. For ISO/</span><span style="background-color: #E0E0E0">IEC</span><span style="background-color: #E0E0E0"> 9945, the case never arises. -- end 
      note</span></i><span style="font-style: italic; background-color: #E0E0E0">]</span><br>
&nbsp;</li>
      <li>Otherwise, return <code>
      file_status(file_type::none)</code>.</li>
    </ul>
        <blockquote>
        <p>[<i>Note:</i> These semantics distinguish between <code>p</code> being known not to exist, <code>p</code> existing but not being able to determine its attributes, 
        and there being an error that prevents even knowing if <code>p</code> exists. These 
        distinctions are important to some use cases.&nbsp;<i>--end note</i>]</p>
    </blockquote>
    <p>Otherwise,</p>
    <ul>
      <li>If the attributes indicate a regular file, as if by ISO/IEC 9945&nbsp;<a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISREG()</a>, 
      return <code>
      file_status(file_type::regular)</code>. [<i>Note:</i> <code>
      file_type::regular</code> implies appropriate <code>&lt;fstream&gt;</code> operations 
      would succeed, assuming no hardware, permission, access, or file system 
      race 
      errors. Lack of
<code>file_type::regular</code> does not necessarily imply <code>&lt;fstream&gt;</code> operations would 
fail on a directory.
<i>-- end note</i>]<br>
&nbsp;</li>
      <li>Otherwise, if the attributes indicate a directory, as if by ISO/IEC 9945
      <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISDIR()</a>, 
      return <code>
      file_status(file_type::directory)</code>. [<i>Note:</i> <code>
      file_type::directory</code> implies <code>
directory_iterator(p)</code>would succeed.
<i>-- end note</i>]<br>
&nbsp;</li>
      <li>Otherwise, if the attributes indicate a block special file, as if by ISO/IEC 9945
      <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISBLK()</a>, 
      return <code>
      file_status(file_type::block)</code>.<br>
&nbsp;</li>
      <li>Otherwise, if the attributes indicate a character special file, as if by ISO/IEC 9945
      <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISCHR()</a>, 
      return <code>
      file_status(file_type::character)</code>.<br>
&nbsp;</li>
      <li>Otherwise, if the attributes indicate a fifo or pipe file, as if by
      ISO/IEC 9945
      <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISFIFO()</a>, 
      return <code>
      file_status(file_type::fifo)</code>.<br>
&nbsp;</li>
      <li>Otherwise, if the attributes indicate a socket, as if by ISO/IEC 
      9945
      <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISSOCK()</a>, 
      return <code>
      file_status(file_type::socket)</code>.<br>
&nbsp;</li>
      <li>Otherwise, return <code>
      file_status(file_type::unknown)</code>.</li>
    </ul>
    </blockquote>
      <p><i>Remarks:</i> If a symbolic link is encountered during pathname 
      resolution, 
      pathname resolution continues using the contents of the symbolic link.</p>
</blockquote>
<pre>bool <a name="status_known">status_known</a>(file_status s) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>s.type() != file_type::none</code></p>
</blockquote>
<pre>file_status <a name="symlink_status">symlink_status</a>(const path&amp; p);
file_status <a name="symlink_status2">symlink_status</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects:</i>&nbsp; Same as <a href="#status">status()</a>, above, 
  except that the attributes 
    of <code>p</code> are determined as if by ISO/IEC 9945 <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/lstat.html">lstat()</a></code>.</p>
</blockquote>
<blockquote>
      <p><i>Returns:</i> Same as <a href="#status">status()</a>, above, except 
      that if the attributes indicate a symbolic link, as if by ISO/IEC 9945 <a class="external" href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISLNK()</a>, return <code>
      file_status(file_type::symlink)</code>. 
      The signature with argument <code>ec</code> returns <code>
      file_status(file_type::none)</code> if an error occurs.</p>
      <p><i>Remarks:</i> Pathname resolution terminates if <code>p</code> names a symbolic link.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
</blockquote>
<pre>path <a name="system_complete">system_complete</a>(const path&amp; p);
path <a name="system_complete2">system_complete</a>(const path&amp; p, error_code&amp; ec);</pre>
<blockquote>
  <p><i>Effects:</i> Composes an absolute path from <code>p</code>, using the 
  same rules used by the operating system to resolve a path passed as the 
  filename argument to standard library open functions.</p>
  <p><i>Returns:</i> The composed path. The signature with argument <code>ec</code> 
  returns <code>path()</code> if an error occurs.</p>
  <p><i>Postcondition:</i> For the returned path, <code>rp,</code> <code>rp.is_absolute()</code> is true.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
  
<blockquote>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse"
   bordercolor="#111111" width="90%" bgcolor="#E8FFE8">
    <tr>
      <td width="100%">
  
  <p>[<i>Example:</i> For ISO 9945/POSIX based operating systems, <code>system_complete(p)</code>
  has the same semantics as <code>complete(p, current_path())</code>.</p>
  <p>For Windows based operating systems, <code>system_complete(p)</code> has the 
  same semantics as <code>absolute(ph, current_path())</code> if <code>p.is_absolute() ||
  !p.has_root_name()</code> or <code>p</code> and <code>base</code> have the same
  <code>root_name()</code>. 
  Otherwise it acts like <code>absolute(p, kinky)</code>, where <code>kinky</code> is
  the current directory for the <code>p.root_name()</code> drive. This will 
  be the current directory for that drive the last time it was set, and thus may 
  be <b>residue left over from a prior program</b> run by the command 
  processor! Although these semantics are useful, they are very 
  error-prone. <i>-- end example</i>]</p>
  
      </td>
    </tr>
  </table>
</blockquote>
  
</blockquote>
<pre>path <a name="temp_directory_path">temp_directory_path</a>();
path temp_directory_path(error_code&amp; ec);</pre>
<blockquote>
  <p><i>Returns:</i> An operating system dependent directory path suitable for temporary files. An error shall be reported if<code> !exists(p) 
  || !is_directory(p)</code>, where <code>p</code> is the path to be returned. 
  The signature with argument <code>ec</code> returns <code>path()</code> if an 
  error occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
  <p><i><span style="background-color: #E0E0E0">The <code>temp_directory_path()</code> 
  name was chosen to emphasize that the return is a path, not just a single 
  directory name.</span></i></p>
<blockquote>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse"
   bordercolor="#111111" width="90%" bgcolor="#E8FFE8">
    <tr>
      <td width="100%">
  
  <p>[<i>Example:</i> For ISO 9945/POSIX based operating systems, the path 
  supplied by the first environment variable found in the list TMPDIR, TMP, TEMP, TEMPDIR. If none of these are found, <code>&quot;/tmp&quot;</code>.</p>
  <p>For Windows based operating systems, the path reported by the <i>Windows</i> <code>GetTempPath</code> API function. <i>-- end example</i>]</p>
  
      </td>
    </tr>
  </table>
</blockquote>
</blockquote>
<pre>path <a name="unique_path">unique_path</a>(const path&amp; model=&quot;%%%%-%%%%-%%%%-%%%%&quot;);
path unique_path(const path&amp; model, error_code&amp; ec);</pre>
<blockquote>
  <p>The <code>unique_path</code> function generates a name suitable for temporary files, including directories. The name is based 
  on a model that uses the percent sign character to specify replacement by a 
  random hexadecimal digit.</p>
  <p>[<i>Note:</i> The more bits of randomness in the 
  generated name, the less likelihood of prior existence or being guessed. 
  Each replacement hexadecimal digit in the model adds four bits of randomness. 
  The default model thus provides 64 bits of randomness. <i>--end note</i>]</p>
  <p><i>Returns:</i> A path identical to <code>model</code>, except that each 
  occurrence of the percent sign character is replaced by a random hexadecimal 
  digit character in the range 0-9, a-f. The signature with argument <code>ec</code> 
  returns <code>path()</code> if an error occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting</a>.</p>
  <p><i>Remarks:</i> Implementations are encouraged to obtain the required 
  randomness via a <a href="http://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator">cryptographically secure pseudo-random number generator</a>, such as one 
  provided by the operating system. [<i>Note</i>: Such generators may block 
  until sufficient entropy develops. <i>--end note</i>]</p>
  <p>[<i>Example</i>:</p>
  <blockquote>
    <pre>cout &lt;&lt; unique_path(&quot;test-%%%%%%%%%%%.txt&quot;) &lt;&lt; endl;</pre>
  </blockquote>
  <p>Typical output would be <code>&quot;test-0db7f2bf57a.txt&quot;</code>. Because 11 
  hexadecimal output characters are specified, 44 bits of randomness are 
  supplied.&nbsp; <i>-- end example</i>] </p>
</blockquote>
<hr>


 </p>
<p><span style="font-style: italic; background-color: #E0E0E0">End of Proposed 
wording.</span></p>
<hr>
<p>

<p></p>
<h2><a name="Acknowledgements">Acknowledgements</a></h2>
<p>This Filesystem Library is dedicated to my wife, Sonda, who provided the 
support necessary to see both a trial implementation and the proposal itself 
through to completion. She gave me the strength to continue after a difficult 
year of cancer treatment in the middle of it all.</p>
<p>Many people contributed technical comments, ideas, and suggestions to the 
Boost Filesystem Library. See <a href="http://www.boost.org/libs/filesystem/doc/index.htm#Acknowledgements">http://www.boost.org/libs/filesystem/doc/index.htm#Acknowledgements</a>.</p>
<p>Dietmar Kuehl contributed the original Boost Filesystem Library directory_iterator design. Peter Dimov, Walter Landry, Rob Stewart, and Thomas 
Witt were particularly helpful in refining the library.</p>
<p>The create_directories, extension, basename, and replace_extension functions 
were developed by Vladimir Prus. The temp_directory_path function was 
contributed by Jeff Flinn. David Svoboda suggested the canonical function and 
provided psuedo-code. The Library Working Group requested the removal of 
explicit codecvt arguments, leading to the separation of string interoperability 
features into a separate library.</p>
<p>Howard Hinnant and John Maddock reviewed a draft of the version 2 proposal, and 
identified a number of mistakes or weaknesses, resulting in a more polished 
final document.</p>
<p>Peter Dimov suggested a single class path, with member templates to adapt to 
multiple string types. His idea became the basis for the version 3 path design.</p>
<h2><a name="References">References</a></h2>
<table border="0" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%">
  <tr>
    <td width="16%" valign="top">[<a name="ISO_POSIX">ISO/IEC 9945</a>]</td>
    <td width="84%">ISO/IEC 9945:2003, IEEE&nbsp;Std&nbsp;1003.1-2001, and The Open Group 
    Base Specifications, Issue 6. Also known as The Single Unix<font face="Times New Roman">® 
    Specification, Version 3. Available from each of the organizations involved 
    in its creation. For example, read online or download from <a href="http://www.unix.org/single_unix_specification/">www.unix.org/single_unix_specification/</a>.</font> The ISO JTC1/SC22/WG15 - 
    POSIX homepage is <a href="http://www.open-std.org/jtc1/sc22/WG15/">www.open-std.org/jtc1/sc22/WG15/</a></td>
  </tr>
  <tr>
    <td width="16%" valign="top">[<a name="ISO-Drafting">ISO Drafting</a>]</td>
    <td width="84%">ISO/IEC Directives, Part 2: Rules for the structure and 
    drafting of International Standards. http://www.iso.org/iso/standards_development/processes_and_procedures/iso_iec_directives_and_iso_supplement.htm</td>
  </tr>
  <tr>
    <td width="16%" valign="top">[Abrahams]</td>
    <td width="84%">Dave Abrahams, Error and Exception Handling, <a href="http://www.boost.org/more/error_handling.html">www.boost.org/more/error_handling.html</a></td>
  </tr>
</table>
<hr>


</body></html>
